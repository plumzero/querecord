
协程是 Go 语言提供的一种用户态线程。协程在某种程度上也可以叫作轻量级线程，它不由系统而由应用程序创建和管理，因此使用开销较低(一般为 4KB)。当创建很多的协程，并且它们运行在同一个内核线程之上的时候，就需要一个调度器来维护这些协程，确保它们都能使用 CPU，并且尽可能公平地使用 CPU 资源。

调度器主要有 4 个重要部分，分别是 M、G、P、Sched。
* M(work thread): M 代表系统线程(OS Thread)，由操作系统管理。
* P(processor): P 衔接 M 和 G 的调度上下文，负责将等待执行的 G 与 M 对接。P 的数量可以通过 `GOMAXPROCS()` 来设置，它其实也就代表了真正的并发度，即有多少个协程可以同时运行。
* G(goroutine): G 是协程的实体，包括了调用栈，处理重要的调度信息，例如 channel 等。

在操作系统的 OS Thread 和编程语言的 User Thread 之间，实际上存在三种线程对应模型，即 1:1、n:1 和 m:n 。
* n:1 表示多个(n)用户线程始终在一个内核线程上运行，上下文切换很快，但是无法真正利用多核。
* 1:1 表示一个用户线程只在一个内核线程上运行，这时可以利用多核，但是上下文切换很慢，切换效率很低。
* m:n 表示多个协程(m)在多个内核线程(n)上运行，它集齐了前面两者的优势，但也增加了调度的复杂度，Go 语言选择了这种方式。

Go 语言中的协程是运行在多核 CPU 中的(通过 runtime.GOMAXPROCS(1) 设定 CPU 核心数)。实际中运行的 CPU 核数未必等于实际物理 CPU 数。

每个 goroutine 都会被一个特定的 P(某个 CPU) 选定维护，而 M(物理计算资源)每次挑选一个有效 P，然后执行 P 中的协程。每个 P 会将自己所维护的协程放到一个 G 队列中，其中就包括了协程堆栈信息、是否可执行信息等。

默认情况下，P 的数量与实际物理 CPU 的数量相等。当通过循环来创建协程时，协程会被分配到不同的 G 队列中。而 M 的数量不是唯一的，当 M 随机挑选 P 时，也就相当于随机挑选了协程。所以，当碰到多个协程的执行顺序不是我们想象的顺序时就可以理解了，因为协程进入 P 管理的队列 G 是随机的。

P 的数量由 runtime.GOMAXPROCS(1) 设定，通常它是和内核数对应的，例如在 4 核的服务器上会启动 4 个线程。G 会有很多个，每个 P 会将 goroutine 从一个就绪的队列中做出出栈操作。为了减小锁的竞争，通常情况下每个 P 会负责一个队列。例如:
```go
    runtime.NumCPU()        // 返回当前 CPU 内核数
    runtime.GOMAXPROCS(2)   // 设置运行时最大可执行 CPU 数
    runtime.NumGoroutine()  // 当前正在运行的 goroutine 数
```
P 维护着这个队列(称为 runqueue)。Go 语言里，通过关键字 go 启动一个 goroutine，它会被添加到 runqueue 队列末尾，在下一个调度点，就从 runqueue 中取出一个 goroutine 执行。

假如有两个 M，即两个 OS Thread，分别对应一个 P，每一个 P 调度一个 G 队列。它们的执行情况是这样的:
* 当有一个 M 返回时，必须尝试取得一个 P 来运行协程，一般情况下，它会从其他的内核态线程那里截取一个 P 过来，如果没有拿到，就把协程放在一个 global runqueue 里，然后自己进入线程缓存。
* 如果某个 P 所分配的任务 G 很快就执行完了，就会导致多个队列存在不平衡，会从其他队列中截取一部分协程(一般会取 runqueue 的一半)到 P 上进行调度，这就确保了每个内核态线程都能充分使用。
* 当一个内核态线程被阻塞时，P 可以转而投奔另一个内核态线程。

[设定GOMAXPROCS测试](t/06_gomaxprocs.go)

在实际运行中，运行速度延缓不一定是由于 CPU 的竞争，可能还有内存或者 I/O 的原因，需要具体分析。

最后，`runtime.Gosched()` 用于让出 CPU 时间片，让出当前 goroutine 的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。
