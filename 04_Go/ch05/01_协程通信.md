
协程(Coroutine)本质上是一种用户态线程，不需要操作系统来抢占式调度，且在真正的实现中寄存于线程中，因此，系统开销极小，可以有效提高线程的任务并发性，避免多线程的缺点。

传统线程之间的通信只能采用共享内存的方式。为了保证共享内存的有效性，往往需要进行同步或者避免线程"饿死"。

还有一种系统模型，它基于消息传递。对线程间共享状态的各种操作都被封装在线程之间传递的消息中，这通常要求: 发送消息时对状态进行复制，并且在消息传递的边界上交出这个状态的所有权。

由于需要执行复制操作，所以大多数消息传递的实现在性能上并不优越，但在线程中的状态管理工作通常会变得更为简单。

Go 语言中的协程就是基于消息传递模型实现的。

与传统的系统级线程和进程相比，协程的最大优势在于其"轻量级"，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过 1 万个。

Go 语言在语言级别支持轻量级线程，叫 goroutine 。

[协程示例](t/01_goroutine.go)

goroutine 的调度方式是协同式的。在协同式调度中没有"时间片"的概念。为了并行执行 goroutine，调度器会在以下几个时刻对其进行切换:
* 在通道发送或者接收数据且造成阻塞时。
* 在一个新的 goroutine 被创建时。
* 在可以造成系统调用被阻塞时，如在进行文件操作时。

Go 语言标准库提供的所有系统调用操作(当然也包括所有同步 IO 操作)，都会出让 CPU 给其他 goroutine 。这样，协程的切换管理不依赖于系统的线程和进程，也不依赖于 CPU 的核心数量。

Note: 因为 Go 在进行系统调用操作时会出让 CPU 时间片，所以个人理解 Go 的协程不建议进行太多的系统调用，不然所有的协程都在出让，就没有干活的了。

