
Go 内置有以下基础类型:

| 类型说明    |   表达式   |
|:-----------|:-----------|
| 布尔类型    | bool       |
| 整型        | int8 byte int16 int uint uintptr |
| 浮点类型    | float32 float64 |
| 复数类型    | complex64 complex128 |
| 字符串      | string |
| 字符类型    | rune   |
| 错误类型    | error |

Go 也支持如下复合类型:

| 类型说明   | 表达式 |
|:----------|:-------|
| 指针      | pointer |
| 数组      | array   |
| 切片      | slice   |
| 字典      | map     |
| 通道      | chan    |
| 结构体    | struct  |
| 接口      | interface |

[基础类型计算测试](t/03_type_calc.go)

### 布尔类型

布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。
```go
  var v1 bool
  v1 = true       // ok
  v2 := (1 == 2)  // ok
  
  var b bool
  // b = 2        // compiled error
  // b = bool(2)  // compiled error
```


### 整型

`int` 和 `int32` 在 Go 语言里被认为是两种不同的类型，编译器不会对这两种类型进行自动转换；

使用强制类型转换可以解决类似于 int 和 int32 之间转换的问题，但要注意精度损失和值溢出问题。
```go
    var value2 int32
    value1 := 64            // deduced value1 type as int
    // value2 = value1      // compiled error
    value2 = int32(value1)  // ok
```

Go 支持全套比较运算符。不过两个不同的整型数不能直接比较，比如 int8 类型的数和 int 类型的数不能直接比较。但各种类型的整型变量都可以直接与字面常量(literal)进行比较:
```go
    var i int32
    var j int64
    
    i, j = 1, 2
    
    if i == j {             // 编译错误
        fmt.Println("i and j are equal.")
    }
    
    if i == 1 || j == 2 {   // 编译通过
        fmt.Println("i and j are equal.")
    }
```
Go 支持位运算，如下:

| 运算符  | 含义 |
|:-------|:------|
| x << y | 左移  |
| x >> y | 右移  |
| x ^ y  | 异或  |
| x & y  | 与    |
| x | y  | 或    |
| ^x     | 取反  |


### 浮点类型

Go 语言定义了两种浮点类型, float32 和 float64, 其中 float32 等价于 C 语言的 float 类型，float64 等价于 C 语言的 double 类型。

不同类型的浮点数之间不能进行赋值操作，必要时可进行强制类型转换。
```go
  var fvalue1 float32
  fvalue2 := 12.0       // deduced as float64

  // fvalue1 = fvalue2  // compiled error
  fvalue1 = float32(fvalue2)  // ok
```


### 字符串

在 Go 中，字符串也是一种基本类型。因此当传递一个字符串时(如函数参数传递)，属于值传递。

字符串支持如下操作:

| 运算操作  | 含义      | 样例        | 样例运行结果 |
|:---------|:----------|:------------|:------------|
| x + y    | 字符串连接 | "Hello" + "123" | "Hello123" |
| len(s)   | 字符串长度 | len("Hello") | 5 |
| s[i]     | 取字符     | "Hello"[1]  | 'e' |

与 C/C++ 不同的是，Go 语言中的字符串不需要借助字符数组来表示，而是以静态方式存储。所以当字符串初始化以后，不能像操作字符数组那样直接修改字符串的内容。

也因为 string 都是不可改变的，每次使用 + 运算符都会产生一个新的字符串，这会导致产生很多临时的、无用的字符串，会给 gc 带来额外负担，所以这种方式性能较差。

[程序示例](t/03_string.go)

对包含中文字符的字符串进行遍历时，最好先将字符串转成 `[]rune` 切片，然后再用常规方式进行遍历。

[带中文字符的字符串遍历](t/03_string_ch_in.go)


### 字符类型

Go 语言支持两个字符类型，一个是 byte(实际是 uint8 的别名)，代表 UTF-8 字符串的单个字节的值；另一个是 rune, 代表单个 Unicode 字符，是 int32 的别名。


### 数组

常规的数组声明方式:
```go
  [32]byte                    // 长度为 32 的数组，每个元素为一个字节
  [2*N] struct { x, y int32 } // 复杂类型数组
  [1000] *float64             // 指针数组
  [3][5] int                  // 多维数组
```
Go 语言通过内置函数 `len()` 可以获取数组长度:
```go
  arrLength := len(arr)
```

Go 提供了多种快速创建数组并初始化的方法:
```go
  array := [5]int{ 10, 20, 30, 40, 50 }
  array := [...]int{ 10, 20, 30, 40, 50 }   // 数组长度由初始化值的数量决定
  array := [5]int{ 1: 10, 2: 20 }           // 对指定的索引进行特定初始化
```

Go 提供两种遍历数组的方式: 基于索引和基于范围(关键字 `range`)。

[遍历数组程序](t/03_array_traverse.go)

需要注意的是，在 Go 语言中数组是一个值类型(value type)。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。

[数组值传递示例程序](t/03_array_value_copy.go)

[三维数组的使用](t/03_triple_dimensions.go)


### 数组切片

Go 原生数组有一些缺点，如数组的长度在定义之后无法再次修改、数组的值类型等，这些会在开发过程中造成一些局限。

Go 语言提供了数组切片(slice)来弥补数组的不足。从底层实现的角度来看，数组切片实际上仍然使用数组来管理元素。同时基于数组，数组切片添加了一系列管理功能，可以随时动态扩充存放空间，并且可以被随意传递而不会导致所管理的元素被重复复制。

数组切片的数据结构可以抽象为以下 3 个变量:
- 一个指向原生数组的指针
- 数组切片中的元素个数
- 数组切片已分配的存储空间

数组切片创建方法主要有很多，可以是基于数组和直接创建，甚至基于其他数组切片。

> 基于数组
  
  Go 语言支持用 `array[first:last]` 方式来基于数组生成一个数组切片。
  ```go
    mySlice = myArray[:]        // 基于 myArray 的所有元素创建数组切片
    mySlice = myArray[:5]       // 基于 myArray 的前 5 个元素创建数组切片
    mySlice = myArray[5:]       // 基于从第 5 个元素开始的所有元素创建数组切片
  ```

> 直接创建
          
  Go 语言提供的内置函数 `make()` 可以用于灵活地创建数组切片。
  ```go
    mySlice1 := make([]int, 5)            // 创建一个初始元素个数为 5 的数组切片，元素初始值为 0
    mySlice2 := make([]int, 5, 10)        // 在上面的基础上预留 10 个元素的存储空间
    mySlice3 := []int{1, 2, 3, 4, 5}      // 直接创建并初始化包含 5 个元素的数组切片
  ```
  
> 基于数组切片
  ```go
    oldSlice := []int{1, 2, 3, 4, 5}
    newSlice := oldSlice[:3]              // 基于 oldSlice 的前 3 个元素构建新数组切片
  ```

操作数组元素的所有方法都适用于数组切片。如索引操作、`len`、遍历操作等。

[遍历数组切片程序示例](t/03_slice_traverse.go)

与数组相比，数组切片多了一个存储能力(capacity)的概念。数组切片支持 Go 语言内置的 `cap()` 函数和 `len()` 函数。前者返回的是数组切片分配的空间大小，后者返回的是数组切片中当前所存储的元素个数。

[切片存储能力与长度程序示例](t/03_slice_cap.go)

数组切片通过 `append()` 函数支持动态追加元素操作。追加对象可以是一系列同类型元素或者同类型数组切片。
```go
  mySlice = append(mySlice, 1, 2, 3)

  mySlice2 := []int{8, 9, 10}
  mySlice = append(mySlice, mySlice2...)
```
函数 append() 总是会增加新切片的长度，而容量有可能会改变，也可能不会改变，这取决于被操作的切片的可用容量。
如果切片的底层数组没有足够的可用容量，那么 append() 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组中，再追加新的值。

在一个切片基础上重新划分一个切片时，新的切片会继续引用原有切片的相关数组。如果忘了这个行为的话，在程序内分配占用大量内存的临时切片，然后在这个临时切片的基础上只引用一小部分原有数据的新切片时，会导致难以预期的内存使用效果:
```go
    func get() []byte {
        raw := make([]byte, 10000)
        return raw[:3]          // 只引用了 3 个，其他空间浪费了
    }
```
为了避免这个陷阱，可以在临时的切片中使用内置函数 `copy()`，复制数据到新切片:
```go
  slice1 := []int{1, 2, 3, 4, 5}
  slice2 := []int{5, 4, 3}
  
  copy(slice2, slice1)    // 只会复制 slice1 的前 3 个元素到 slice2 中 
  copy(slice1, slice2)    // 只会复制 slice2 的 3 个元素到 slice1 的前 3 个位置
```

危险！陈旧的切片。

多个切片可以引用同一个底层数组。某些情况下，在一个切片中添加新的数据，在原有数组无法保持更多新的数据时，将导致分配一个新的数组。而其他的切片还指向旧的数组(和旧的数组)。


### map

map 通过使用哈希表实现，是一种无序的键值对集合，所以并不能保证针对相同 map 的遍历都有同样的序列输出。

由于 map 是一种集合，所以可以像迭代数组和切片那样迭代它。

map 的声明方式如下:
```go
  var myMap map[string] PersonInfo
```
其中，myMap 是声明的 map 变量名， string 是键的类型， PersonInfo 则是其中所存放的值类型。

其初始化方法如下:
```go
  myMap = map[string] PersonInfo {
      "1234" : PersonInfo {"1", "Jack", "Room 101,..."},
  }
```

也可以通过内置函数 `make()` 可以创建一个 map:
```go
  myMap = make(map[string] PersonInfo)
  myMap = make(map[string] PersonInfo, 100)     // 在创建时指定该 map 的初始存储能力
```

map 支持索引方式的赋值或更新操作:
```go
  myMap["1234"] = PersonInfo{"1", "Jack", "Room 101,..."}
```

Go 语言提供了一个内置函数 delete()，用于删除 map 内的元素:
```go
  delete(myMap, "1234")
```

Go 语言提供了便利的元素查找操作:
```go
  value, ok := myMap["1234"]
  if ok {     // 找到了
      // ...
  }
```

[map示例程序](t/03_map.go)
