
## 问题说明
- 描述
    + http客户端**多线程**发送共计 10000 条请求，并对返回结果进行统计。
    + 变量 m_counter_200 和 m_counter_right 分别统计返回状态为 200 的数量，以及后者在前者的基础上，再统计 body 实际尺寸是否与 Content-Length 值相同的数量。
- 测试场景一
    + 客户端产生字符串，发送给服务端，服务端收到后，给客户端以响应。
    + 客户端收到响应串后控制台打印。
    + 统计结果: m_counter_200=100000 m_counter_right=100000 正常。
- 测试场景二
    + 基于场景一，但客户端收到响应后不再进行控制台打印
    + 统计结果: m_counter_200=99889 m_counter_right=99889 异常。
- 原因分析
    + 两个统计变量均是 int 型，且是共享的，多线程可能会同时操作这两个变量，造成同时读或写，引发异常。

## 解决办法
- 将统计变量定义为原子型
  ```c++
    std::atomic<int> m_counter_200;
    std::atomic<int> m_counter_right;
  ```
- 修改后最终测试结果
    + 统计数据正常

## 结论其他
- 多线程情况下，不妨考虑使用原子变量。
- 原子变量禁用了拷贝构造函数，也就是说内聚了原子变量的类对象，基本与容器及标准库算法无缘了。
- 所以原子变量多用于全局处理，也可以与单例模式结合使用。