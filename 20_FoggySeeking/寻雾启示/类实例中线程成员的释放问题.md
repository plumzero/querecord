
## 说明

对于含有线程成员的类实例对象，对其线程成员的管理是一件比较困难的事情，这主要体现在对于线程成员的销毁与替换。


## 销毁

成员线程创建后，通常会立即调用 detach() 函数进行分离。这样做的好处是程序员可以不用在对象析构函数中编写对于线程成员销毁的代码，而是在线程成员离开作用域(所在类的生命周期)时由系统自动释放。

下面来分析一下使用这种方法处理的弊端。

实例对象销毁时，理想且正常的情况下，应该是先释放线程成员，再调用析构函数本身。这样可以保证线程与类实例的安全释放。

事实上，虽然线程成员是类的成员，但构成线程的部件毕竟包含一些全局系统资源，这样在类实例调用析构函数的同时，线程成员也一并因为离开作用域而释放自己所包含的全局资源。可以看出，线程成员释放资源与析构函数的执行并不是先后有序的。

这就很有可能会出现一个问题，那就是系统运行时错误。这种错误不会在程序运行中间发生，而是会在程序退出时(如main函数外)概率性出现。


## 替换

在类实例 A 运行中间某一时刻，如果想要将类资源转移(move)到类实例 B 上，可以使用 std::move 进行处理。对于线程成员，可能需要重新加载对应回调(这样做的一个原因，如需要对线程内资源重新进行一些初始化的处理，而如果直接 move 原来的线程的话，则可能会不执行这一步)。

这就可能需要对原来的线程回调进行替换。


## 一种解决方法

由程序员手动管理线程，如可以单独编写一个清理线程的函数，在析构函数调用之前执行。

注: 清理线程的操作不要在析构函数中编写，因为并不能保证操作系统是按特定顺序来释放资源的。

参考示例:
- [线程成员的 move](测试程序/move_thread.cpp)
- [线程成员的替换与销毁](测试程序/new_thread.cpp)
