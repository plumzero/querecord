
### 保存序列中的增量值

iota() 函数模板会用连续的 T 类型值填充序列。前两个参数是定义序列的前向迭代器，第三个参数是初始的 T 值。

T 类型必须支持 operator++() 运算符。

第三个指定的值会被保存为序列的第一个元素，之后序列中的值是对前面的值运用自增运算符得到。

[iota用法示例](02_numeric/01_iota.cpp)


### 累计运算

accumulate() 的前两个参数定义序列的输入迭代器，第三个参数是初值，也决定了返回值的类型。

accumulate() 重载版本的第 4 个参数定义了一个应用到累计值和元素之间的二元函数对象。

accumulate() 不仅可以用做加法，也可以是任何不修改操作数或不使定义范围的迭代器无效的运算。

[accumulate用法示例](02_numeric/02_accumulate.cpp)


### 内积

两个 vector 的内积是对应元素的乘积之和。为了能够得到内积，vector 的长度必须相同。

内积是矩阵算术的基本运算。两个矩阵的乘积是一个矩阵，它是由第一个矩阵的每一行乘以第二个矩阵的每一列得到的。

inner_product()算法可以计算两个 vector 的内积。这个函数模板有 4 个参数: 前两个参数定义第一个vector的输入迭代器，第 2 个参数定义第二个vector的开始输入迭代器，第 4 个参数是和的初值。

inner_product() 会返回vector的内积。

[inner_product用法示例](02_numeric/03_inner_product.cpp)


### 相邻差

adjacent_difference()算法可以算出输入序列中相邻元素对的差，并将它们保存到另一个序列中。

第一个元素会被原封不动地复制到新的序列中，然后用第二个元素减去第一个元素的结果作为新序列的第二个元素，再用第三个元素减去第二个元素的结果作为新序列的第三个元素，以此类推。

[adjacent_difference用法示例](02_numeric/04_adjacent_difference.cpp)


### 部分和

partial_sum()算法可以计算输入序列中元素的部分和，并将结果保存到一个输出序列中。

它会计算出输入序列中长度从 1 开始不断增加的序列的和，所以第一个输出值就是第一个元素，下一个值是前两个元素的和，再下一个值就是前三个元素的和，以此类推。

[partial_sum用法示例](02_numeric/05_partial_sum.cpp)


### 极大值和极小值

- min_element() 会返回一个指向输入序列的最小元素的迭代器。
- max_element() 会返回一个指向输入序列的最大元素的迭代器。
- minmax_element() 会以 pair 对象的形式返回以上两个迭代器。

序列必须为正向迭代器。传入参数除了用于定义序列的开始和结束迭代器，也可以选择提供第三个参数来定义比较函数。

[用法示例](02_numeric/06_minmax_element.cpp)
