

### 基本使用

C++ 提供了一个原子类型 `std::atomic<T>`, 可以使用任意类型作为模板参数，C++11 内置了整型的原子变量，可以更方便地使用原子变量。

使用原子变量就不需要使用互斥量来保护该变量了。

用于进行统计:
```c++  
  struct AtomicCounter {
    std::atomic<int> value;
    
    void increment()
    {
      ++value;
    }
    
    void decrement()
    {
      --value;
    }
    
    int get()
    {
      return value.load();
    }
  };
```

atomic 和 volatile:
- 使用 volatile 会保证每次都从内存中拿数据，但不能保证并发情况时的安全性，这依赖于编译器的处理。
- 所以并发使用 atomic，特种内存使用 volatile。

### 指令重排序

对于如下的代码:
```c++
  volatile available(false);
  auto imptval = computeImportantValue();
  available = true;
```

在多核心 CPU 机器上，可能会按下面这样的顺利执行:
```c++
  volatile available(false);
  available = true;
  auto imptval = computeImportantValue();
```

而使用原子变量可以让程序以代码书写顺利进行执行:
```c++
  std::atomic<bool> available(false);
  auto imptval = computeImportantValue();
  available = true; // 等价于 available.store(true, std::memory_order_seq_cst);
```

- [程序示例](t/04_atomic.cpp)
- [自旋锁示例](t/04_spin_mutex.cpp)

### 内存序

内存序种类的枚举定义如下:
```c++
  typedef enum memory_order {
    memory_order_relaxed,     // weak atomic
    memory_order_consume,
    memory_order_acquire,     // read barrier
    memory_order_release,     // write barrier
    memory_order_acq_rel,     // read and write barrier
    memory_order_seq_cst      // sync
  } memory_order;
```
如果需要实现一些无锁化的数据结构，可以对内存序进行研究。
