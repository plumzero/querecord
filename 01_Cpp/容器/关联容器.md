
### 说明

C++ 提供了 4 种关联容器，每种关联容器都有不同的特性:

- map<K,T>

    map<K,T> 容器保存的是 pair<const K,V> 类型的元素。pair<const K,T> 封装了一对键/对象，键的类型是 K, 对象的类型是 T。每个键都是唯一的，所以不允许有重复的键，但可以保存重复的对象，只要它们的键不同。
    
    map 容器中的元素都是有序的，元素在容器内的顺序是通过比较键确定的。默认使用 less<T> 对象比较。

    [more map](12_Map.md)

- multimap<K,T>
    
    multimap<K,T> 容器和 map<K,T> 容器类似，也会对元素排序。它的键必须是可比较的，元素的顺序是通过比较键确定的。
    
    和 map<K,T> 不同的是，multimap<K,T> 允许使用重复的键。因此，一个 multimap 容器可以保存多个具有相同键值的 <const K,T> 元素。
    
    [more multimap](13_Multimap.md)

- unordered_map<K,T>
    
    unordered_map 包含的是有唯一键的键/值对元素。容器中的元素不是有序的。
    
    unordered_map<K,T> 中的 pair<const K,T> 元素的顺序并不是直接由键值确定的，而是由键值的哈希值决定的。
    
    元素的位置由键的哈希值确定，因而必须有一个适用于键类型的哈希函数。如果用类对象作为键，需要为它定义一个实现了哈希函数的函数对象。
     
    因为键可以不通过搜索就访问无序 map 中的对象，所以可以很快检索出无序 map 中的元素。迭代遍历无序 map 中的元素序列的速度一般没有有序 map 快，因此在某个应用中选择何种容器取决于想如何访问容器中的元素。

    [more unordered_map](18_Unordered_map.md)
    
- unordered_multimap<K,T>
    
    unordered_multimap<K,T> 也可以通过键值生成的哈希值来确定对象的位置，但它允许有重复的键。


### 改变比较函数

仅针对于有序关联容器 map, multimap, set, multiset 。

关联容器默认严格弱排序。但并非一定要这样，如果执行降序或根据对象中某个成员排序、或者当键为指针时，可能就不得不改变比较函数。

C++11 提供了 std::greater<T> 比较函数。

[greater示例](16_RC_KeyCompare/01_greater.cpp)

如果容器中的键是指针的话，那么需要定义一个函数来比较它们所指向的对象，否则会比较指针所表示的地址。

这个要定义的比较函数一般以函数对象的形式出现。

[程序示例](16_RC_KeyCompare/02_pointer_as_key.cpp)


