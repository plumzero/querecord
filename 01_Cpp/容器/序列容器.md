

### 说明

序列容器以线性序列的方式存储元素。它没有对元素进行排序，元素的顺序和存储它们的顺序相同。

以下有 5 种标准的序列容器，每种容器都具有不同的特性:

- array<T,N>(数组容器)是一个长度固定的序列，有 N 个 T 类型的对象，不能增加或删除元素。

- vector<T>(向量容器)是一个长度可变的序列，用来存放 T 类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素。

- deque<T>(双向队列容器)是一个长度可变的、可以自动增长的序列，在序列的两端都不能高效地增加或删除元素。

- list<T>(链表容器)是一个长度可变的、由 T 类型对象组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。访问容器中任意元素的速度比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素访问，需要沿着链表移动，直到到达想要的元素。

- forward_list<T>(正向链表容器)是一个长度可变的、由 T 类型对象组成的序列，它以单链表的形式组织元素，是一类比链表容器快、更节省内存的容器，但是它内部的元素只能从第一个元素开始访问。


### 关系运算符

C++ 为序列容器提供了 6 种关系运算符，用于两个同类型(对于 array 还要保证相同尺寸)容器对象之间的比较。

| 运算符 |
|:------:|
| a == b |
| a != b |
| a > b  |
| a < b  |
| a >= b |
| a <= b |

> 关系运算符在几个序列容器中的应用示例

[array](08_SC_RelationalOperators/RO_array.cpp)

[vector](08_SC_RelationalOperators/RO_vector.cpp)

[deque](08_SC_RelationalOperators/RO_deque.cpp)

[list](08_SC_RelationalOperators/RO_list.cpp)

[forward_list](08_SC_RelationalOperators/RO_forward_list.cpp)


### array<T> 容器

[认识](01_Array_abc.md)

[用法](01_Array_use.md)


### vector<T> 容器

[认识](02_Vector_abc.md)

[用法](02_Vector_use.md)


### deque<T> 容器

[认识](03_Deque_abc.md)

[用法](03_Deque_use.md)


### list<T> 容器

[认识](04_List_abc.md)

[用法](04_List_use.md)


### 列表 list

- list 提供的是双向迭代器，而不是随机访问迭代器。
- list 给出了 vector 所提供的几乎所有成员类型和操作，例外的就是下标、capacity()和 reserve()。
- 虽然 list 也重载了 [] 操作符，但因为其元素并不是连续存储的，所以其效率未必见得比使用 for 迭
  代更高一些。
- 粘接、排序和归并
  ```c++
    template<class T, class A = allocator<T> > class list {
    public:
        // ...
        void splice(iterator pos, list& x);             // 将 x 的所有元素移到本表的 pos 之前，且不作复制。操作后 x 为空表
        void splice(iterator pos, list& x, iterator p); // 将 x 中的 *p 移到本表的 pos 之前，且不作复制。操作后 *p 不再是 x 的元素
        void splice(iterator pos, list& x, iterator first, iterator last);
        void merge(list&);      // 归并排序的表
        template<class Cmp> void merge(list&, Cmp);     // Cmp 为谓词函数
        void sort();
        template <class Cmp> void sort(Cmp);
        // ...
    };
  ```
  merge() 组合起两个排好序的表，方式是将一个 list 的元素都取出来，将它们都放入另一个表，且
  维持正确的顺序。对于 x.merge(y)，操作完成后，y 将变成空表。
- 其他操作
  ```c++
    template<class T, class A = allocator<T> > class list {
    public:
        // ...
        void remove(const T& val);
        template <class Pred> void remove_if(Pred p);   // Pred 是谓词函数
        void unique();                                  // 根据 == 删除重复元素
        template<class BinPred> void unique(BinPred b); // 根据 b 删除重复元素
        void reverse();                                 // 链表反转
        // ...
    };
  ```
  一般使用 unique() 要先使用 sort() 进行操作，因为前者只能删除连续出现的重复元素。

### 双端队列 deque
- 对其两端的操作效率类似于 list, 而其下标操作具有接近 vector 的效率。
- 注意: "在中间"插入和删除元素具有与 vector 一样低效率，而不是类似 list 的效率。

### 容器适配器 stack queue priority_queue
- 容器适配器所提供的是原来容器的一个受限的界面。特别是适配器不提供迭代器，提供它们的意图就
  是为了只经由它们的专用界面使用。

### 堆栈 stack
```c++
    template <class T, class C = deque<T> > 
    class std::stack
    {
    protected:
        C c;
    public:
        typedef typename C::value_type value_type;
        typedef typename C::size_type size_type;
        typedef C container_type;
        
        explicit stack(const C& a = C()) : c(a) {}
        
        bool empty() const { return c.empty(); }
        size_type size() const { return c.size(); }
        
        value_type& top() { return c.back(); }
        const value_type& top() const { return c.back(); }
        
        void push(const value_type& x) { c.push_back(x); }
        void pop() { c.pop_back(); }
    };
```
堆栈也可以采用任何提供了 back()、push_back() 和 pop_back() 的序列作为保存自己元素的容器。

### 队列 queue
```c++
    template <class T, class C = deque<T> >
    class std::queue
    {
    protected:
        C c;
    public:
        typedef typename C::value_type value_type;
        typedef typename C::size_type size_type;
        typedef C container_type;
        
        explicit queue(const C& a = C()) : c(a) {}
        
        bool empty() const { return c.empty(); }
        size_type size() const { return c.size(); }
        
        value_type& front() { return c.front(); }
        const value_type& front() const { return c.front(); }
        
        value_type& back() { return c.back(); }
        const value_type& back() const { return c.back(); }
        
        void push(const value_type& x) { c.push_back(x); }
        void pop() { c.pop_front(); }
    };
```
不同线程中请求程序和服务程序的消息同步处理：
```
    void server(queue<Message>& q, Lock& lck) {
        while (! q.empty()) {
            Message m;
            {
                LockPtr h(lck);         // 只在提取消息时掌握锁
                if (q.empty()) return;  // 其他程序取走了消息
                m = q.front();
                q.pop();
            }
            m.service();                // 调用为请求提供服务的函数
        }
    }
```

### 优先队列 priority_queue
略

