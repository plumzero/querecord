
### volatile 关键字

- volatile 关键字是用来确保在共享数据更新后及时的通知到其他线程的，即**任一线程都会从内存中直接读取 volatile 所修饰的变量**。但这样并不能保证某个线程对变量的操作是原子性的，比如:
  ```c
    volatile int i = 0;

    i++;
  ```
程序一共需要执行读取i, 计算i，再更新i三个操作。但如果这个过程中i的值被其他线程改变，那么这个计算结果最终会覆盖前面的值而造成错误的结果，所以这种操作仍然需要靠锁来控制。

> 对 i 虽然加了 volatile 修饰，但是它只能保证程序在读取这个变量时会从内存中读取。但是中间在涉及到寄存器的计算时，可能是寄存器的值(中间值)。

也就是说， **volatile 能保证变量的可见性，而加锁能保证变量的可见性和原子性**。

[测试程序](t/03_more_write.cpp)

### volatile 应用场景

1. 程序使用 rtos，多线程中都会读写的全局变量需要使用 volatile 定义
2. 中断和主函数中都要读写的全局变量，需要使用 volatile 定义
3. 单片机的寄存器定义，当然这些变量已经由芯片厂商在库函数中完成了定义

volatile 也常与 const 一起使用，这样修饰的变量并不存在常量 ROM 区，而是和一般的变量一样存在 RAM 里面，所以虽然是 const，但是依然无法修改。如果想要修改，直接赋值是不可行的。因为它存在 RAM 区，所以可以用一个指针指向它，通过这个指针对它修改就行了。

我们知道，volatile 多修饰全局变量。通过 const 和 volatile 联合使用，可以防止全局变量被修改。

另外也可以将一组全局变量组成结构体，并使用 const volatile 定义出来，并使用指针写好修改成员变量的函数，待需要修改某个全局变量时就调用相应的方法函数，并注意临界段保护，从而有效避免全局变量泛滥。

[测试程序](t/03_const_volatile.cpp)
