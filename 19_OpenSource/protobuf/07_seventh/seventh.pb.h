// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: seventh.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_seventh_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_seventh_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_seventh_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_seventh_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_seventh_2eproto;
namespace mam {
class Digimon;
class DigimonDefaultTypeInternal;
extern DigimonDefaultTypeInternal _Digimon_default_instance_;
class Digimon_XMapEntry_DoNotUse;
class Digimon_XMapEntry_DoNotUseDefaultTypeInternal;
extern Digimon_XMapEntry_DoNotUseDefaultTypeInternal _Digimon_XMapEntry_DoNotUse_default_instance_;
class IntArray;
class IntArrayDefaultTypeInternal;
extern IntArrayDefaultTypeInternal _IntArray_default_instance_;
class IntMap;
class IntMapDefaultTypeInternal;
extern IntMapDefaultTypeInternal _IntMap_default_instance_;
class IntMap_IntstringEntry_DoNotUse;
class IntMap_IntstringEntry_DoNotUseDefaultTypeInternal;
extern IntMap_IntstringEntry_DoNotUseDefaultTypeInternal _IntMap_IntstringEntry_DoNotUse_default_instance_;
class IntObjMap;
class IntObjMapDefaultTypeInternal;
extern IntObjMapDefaultTypeInternal _IntObjMap_default_instance_;
class IntObjMap_IntobjmapEntry_DoNotUse;
class IntObjMap_IntobjmapEntry_DoNotUseDefaultTypeInternal;
extern IntObjMap_IntobjmapEntry_DoNotUseDefaultTypeInternal _IntObjMap_IntobjmapEntry_DoNotUse_default_instance_;
class StArray;
class StArrayDefaultTypeInternal;
extern StArrayDefaultTypeInternal _StArray_default_instance_;
class SubType;
class SubTypeDefaultTypeInternal;
extern SubTypeDefaultTypeInternal _SubType_default_instance_;
}  // namespace mam
PROTOBUF_NAMESPACE_OPEN
template<> ::mam::Digimon* Arena::CreateMaybeMessage<::mam::Digimon>(Arena*);
template<> ::mam::Digimon_XMapEntry_DoNotUse* Arena::CreateMaybeMessage<::mam::Digimon_XMapEntry_DoNotUse>(Arena*);
template<> ::mam::IntArray* Arena::CreateMaybeMessage<::mam::IntArray>(Arena*);
template<> ::mam::IntMap* Arena::CreateMaybeMessage<::mam::IntMap>(Arena*);
template<> ::mam::IntMap_IntstringEntry_DoNotUse* Arena::CreateMaybeMessage<::mam::IntMap_IntstringEntry_DoNotUse>(Arena*);
template<> ::mam::IntObjMap* Arena::CreateMaybeMessage<::mam::IntObjMap>(Arena*);
template<> ::mam::IntObjMap_IntobjmapEntry_DoNotUse* Arena::CreateMaybeMessage<::mam::IntObjMap_IntobjmapEntry_DoNotUse>(Arena*);
template<> ::mam::StArray* Arena::CreateMaybeMessage<::mam::StArray>(Arena*);
template<> ::mam::SubType* Arena::CreateMaybeMessage<::mam::SubType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mam {

enum ShouldType : int {
  NoneType = 0,
  NameType = 1,
  TimeType = 5,
  ShouldType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ShouldType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ShouldType_IsValid(int value);
constexpr ShouldType ShouldType_MIN = NoneType;
constexpr ShouldType ShouldType_MAX = TimeType;
constexpr int ShouldType_ARRAYSIZE = ShouldType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShouldType_descriptor();
template<typename T>
inline const std::string& ShouldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShouldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShouldType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShouldType_descriptor(), enum_t_value);
}
inline bool ShouldType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShouldType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShouldType>(
    ShouldType_descriptor(), name, value);
}
// ===================================================================

class Digimon_XMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Digimon_XMapEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Digimon_XMapEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  Digimon_XMapEntry_DoNotUse();
  explicit Digimon_XMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Digimon_XMapEntry_DoNotUse& other);
  static const Digimon_XMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Digimon_XMapEntry_DoNotUse*>(&_Digimon_XMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mam.Digimon.XMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_seventh_2eproto);
    return ::descriptor_table_seventh_2eproto.file_level_metadata[0];
  }

  public:
};

// -------------------------------------------------------------------

class Digimon PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mam.Digimon) */ {
 public:
  inline Digimon() : Digimon(nullptr) {}
  virtual ~Digimon();

  Digimon(const Digimon& from);
  Digimon(Digimon&& from) noexcept
    : Digimon() {
    *this = ::std::move(from);
  }

  inline Digimon& operator=(const Digimon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Digimon& operator=(Digimon&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Digimon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Digimon* internal_default_instance() {
    return reinterpret_cast<const Digimon*>(
               &_Digimon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Digimon& a, Digimon& b) {
    a.Swap(&b);
  }
  inline void Swap(Digimon* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Digimon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Digimon* New() const final {
    return CreateMaybeMessage<Digimon>(nullptr);
  }

  Digimon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Digimon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Digimon& from);
  void MergeFrom(const Digimon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Digimon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mam.Digimon";
  }
  protected:
  explicit Digimon(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_seventh_2eproto);
    return ::descriptor_table_seventh_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kXMapFieldNumber = 10,
    kRstFieldNumber = 13,
    kXIaFieldNumber = 14,
    kXStrFieldNumber = 8,
    kXBsFieldNumber = 9,
    kStFieldNumber = 12,
    kXDFieldNumber = 1,
    kXI64FieldNumber = 3,
    kXFFieldNumber = 2,
    kXI32FieldNumber = 5,
    kXUi64FieldNumber = 4,
    kXUi32FieldNumber = 6,
    kXBlFieldNumber = 7,
    kXEnumFieldNumber = 11,
  };
  // map<string, double> x_map = 10;
  int x_map_size() const;
  private:
  int _internal_x_map_size() const;
  public:
  void clear_x_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_x_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_x_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      x_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_x_map();

  // repeated .mam.SubType rst = 13;
  int rst_size() const;
  private:
  int _internal_rst_size() const;
  public:
  void clear_rst();
  ::mam::SubType* mutable_rst(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mam::SubType >*
      mutable_rst();
  private:
  const ::mam::SubType& _internal_rst(int index) const;
  ::mam::SubType* _internal_add_rst();
  public:
  const ::mam::SubType& rst(int index) const;
  ::mam::SubType* add_rst();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mam::SubType >&
      rst() const;

  // repeated int32 x_ia = 14;
  int x_ia_size() const;
  private:
  int _internal_x_ia_size() const;
  public:
  void clear_x_ia();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x_ia(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_x_ia() const;
  void _internal_add_x_ia(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_x_ia();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 x_ia(int index) const;
  void set_x_ia(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_x_ia(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      x_ia() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_x_ia();

  // string x_str = 8;
  void clear_x_str();
  const std::string& x_str() const;
  void set_x_str(const std::string& value);
  void set_x_str(std::string&& value);
  void set_x_str(const char* value);
  void set_x_str(const char* value, size_t size);
  std::string* mutable_x_str();
  std::string* release_x_str();
  void set_allocated_x_str(std::string* x_str);
  private:
  const std::string& _internal_x_str() const;
  void _internal_set_x_str(const std::string& value);
  std::string* _internal_mutable_x_str();
  public:

  // bytes x_bs = 9;
  void clear_x_bs();
  const std::string& x_bs() const;
  void set_x_bs(const std::string& value);
  void set_x_bs(std::string&& value);
  void set_x_bs(const char* value);
  void set_x_bs(const void* value, size_t size);
  std::string* mutable_x_bs();
  std::string* release_x_bs();
  void set_allocated_x_bs(std::string* x_bs);
  private:
  const std::string& _internal_x_bs() const;
  void _internal_set_x_bs(const std::string& value);
  std::string* _internal_mutable_x_bs();
  public:

  // .mam.SubType st = 12;
  bool has_st() const;
  private:
  bool _internal_has_st() const;
  public:
  void clear_st();
  const ::mam::SubType& st() const;
  ::mam::SubType* release_st();
  ::mam::SubType* mutable_st();
  void set_allocated_st(::mam::SubType* st);
  private:
  const ::mam::SubType& _internal_st() const;
  ::mam::SubType* _internal_mutable_st();
  public:
  void unsafe_arena_set_allocated_st(
      ::mam::SubType* st);
  ::mam::SubType* unsafe_arena_release_st();

  // double x_d = 1;
  void clear_x_d();
  double x_d() const;
  void set_x_d(double value);
  private:
  double _internal_x_d() const;
  void _internal_set_x_d(double value);
  public:

  // int64 x_i64 = 3;
  void clear_x_i64();
  ::PROTOBUF_NAMESPACE_ID::int64 x_i64() const;
  void set_x_i64(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_x_i64() const;
  void _internal_set_x_i64(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float x_f = 2;
  void clear_x_f();
  float x_f() const;
  void set_x_f(float value);
  private:
  float _internal_x_f() const;
  void _internal_set_x_f(float value);
  public:

  // int32 x_i32 = 5;
  void clear_x_i32();
  ::PROTOBUF_NAMESPACE_ID::int32 x_i32() const;
  void set_x_i32(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x_i32() const;
  void _internal_set_x_i32(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint64 x_ui64 = 4;
  void clear_x_ui64();
  ::PROTOBUF_NAMESPACE_ID::uint64 x_ui64() const;
  void set_x_ui64(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_x_ui64() const;
  void _internal_set_x_ui64(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 x_ui32 = 6;
  void clear_x_ui32();
  ::PROTOBUF_NAMESPACE_ID::uint32 x_ui32() const;
  void set_x_ui32(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_x_ui32() const;
  void _internal_set_x_ui32(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool x_bl = 7;
  void clear_x_bl();
  bool x_bl() const;
  void set_x_bl(bool value);
  private:
  bool _internal_x_bl() const;
  void _internal_set_x_bl(bool value);
  public:

  // .mam.ShouldType x_enum = 11;
  void clear_x_enum();
  ::mam::ShouldType x_enum() const;
  void set_x_enum(::mam::ShouldType value);
  private:
  ::mam::ShouldType _internal_x_enum() const;
  void _internal_set_x_enum(::mam::ShouldType value);
  public:

  // @@protoc_insertion_point(class_scope:mam.Digimon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Digimon_XMapEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
      0 > x_map_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mam::SubType > rst_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > x_ia_;
  mutable std::atomic<int> _x_ia_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x_str_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x_bs_;
  ::mam::SubType* st_;
  double x_d_;
  ::PROTOBUF_NAMESPACE_ID::int64 x_i64_;
  float x_f_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_i32_;
  ::PROTOBUF_NAMESPACE_ID::uint64 x_ui64_;
  ::PROTOBUF_NAMESPACE_ID::uint32 x_ui32_;
  bool x_bl_;
  int x_enum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seventh_2eproto;
};
// -------------------------------------------------------------------

class SubType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mam.SubType) */ {
 public:
  inline SubType() : SubType(nullptr) {}
  virtual ~SubType();

  SubType(const SubType& from);
  SubType(SubType&& from) noexcept
    : SubType() {
    *this = ::std::move(from);
  }

  inline SubType& operator=(const SubType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubType& operator=(SubType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubType* internal_default_instance() {
    return reinterpret_cast<const SubType*>(
               &_SubType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SubType& a, SubType& b) {
    a.Swap(&b);
  }
  inline void Swap(SubType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubType* New() const final {
    return CreateMaybeMessage<SubType>(nullptr);
  }

  SubType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubType& from);
  void MergeFrom(const SubType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mam.SubType";
  }
  protected:
  explicit SubType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_seventh_2eproto);
    return ::descriptor_table_seventh_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYI32FieldNumber = 1,
  };
  // int32 y_i32 = 1;
  void clear_y_i32();
  ::PROTOBUF_NAMESPACE_ID::int32 y_i32() const;
  void set_y_i32(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y_i32() const;
  void _internal_set_y_i32(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mam.SubType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_i32_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seventh_2eproto;
};
// -------------------------------------------------------------------

class IntArray PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mam.IntArray) */ {
 public:
  inline IntArray() : IntArray(nullptr) {}
  virtual ~IntArray();

  IntArray(const IntArray& from);
  IntArray(IntArray&& from) noexcept
    : IntArray() {
    *this = ::std::move(from);
  }

  inline IntArray& operator=(const IntArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntArray& operator=(IntArray&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntArray* internal_default_instance() {
    return reinterpret_cast<const IntArray*>(
               &_IntArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IntArray& a, IntArray& b) {
    a.Swap(&b);
  }
  inline void Swap(IntArray* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntArray* New() const final {
    return CreateMaybeMessage<IntArray>(nullptr);
  }

  IntArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntArray>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntArray& from);
  void MergeFrom(const IntArray& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntArray* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mam.IntArray";
  }
  protected:
  explicit IntArray(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_seventh_2eproto);
    return ::descriptor_table_seventh_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIarrayFieldNumber = 1,
  };
  // repeated int32 iarray = 1;
  int iarray_size() const;
  private:
  int _internal_iarray_size() const;
  public:
  void clear_iarray();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_iarray(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_iarray() const;
  void _internal_add_iarray(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_iarray();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 iarray(int index) const;
  void set_iarray(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_iarray(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      iarray() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_iarray();

  // @@protoc_insertion_point(class_scope:mam.IntArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > iarray_;
  mutable std::atomic<int> _iarray_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seventh_2eproto;
};
// -------------------------------------------------------------------

class StArray PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mam.StArray) */ {
 public:
  inline StArray() : StArray(nullptr) {}
  virtual ~StArray();

  StArray(const StArray& from);
  StArray(StArray&& from) noexcept
    : StArray() {
    *this = ::std::move(from);
  }

  inline StArray& operator=(const StArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline StArray& operator=(StArray&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StArray* internal_default_instance() {
    return reinterpret_cast<const StArray*>(
               &_StArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StArray& a, StArray& b) {
    a.Swap(&b);
  }
  inline void Swap(StArray* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StArray* New() const final {
    return CreateMaybeMessage<StArray>(nullptr);
  }

  StArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StArray>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StArray& from);
  void MergeFrom(const StArray& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StArray* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mam.StArray";
  }
  protected:
  explicit StArray(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_seventh_2eproto);
    return ::descriptor_table_seventh_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStsFieldNumber = 1,
  };
  // repeated .mam.SubType sts = 1;
  int sts_size() const;
  private:
  int _internal_sts_size() const;
  public:
  void clear_sts();
  ::mam::SubType* mutable_sts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mam::SubType >*
      mutable_sts();
  private:
  const ::mam::SubType& _internal_sts(int index) const;
  ::mam::SubType* _internal_add_sts();
  public:
  const ::mam::SubType& sts(int index) const;
  ::mam::SubType* add_sts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mam::SubType >&
      sts() const;

  // @@protoc_insertion_point(class_scope:mam.StArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mam::SubType > sts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seventh_2eproto;
};
// -------------------------------------------------------------------

class IntMap_IntstringEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IntMap_IntstringEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IntMap_IntstringEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  IntMap_IntstringEntry_DoNotUse();
  explicit IntMap_IntstringEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const IntMap_IntstringEntry_DoNotUse& other);
  static const IntMap_IntstringEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const IntMap_IntstringEntry_DoNotUse*>(&_IntMap_IntstringEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mam.IntMap.IntstringEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_seventh_2eproto);
    return ::descriptor_table_seventh_2eproto.file_level_metadata[5];
  }

  public:
};

// -------------------------------------------------------------------

class IntMap PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mam.IntMap) */ {
 public:
  inline IntMap() : IntMap(nullptr) {}
  virtual ~IntMap();

  IntMap(const IntMap& from);
  IntMap(IntMap&& from) noexcept
    : IntMap() {
    *this = ::std::move(from);
  }

  inline IntMap& operator=(const IntMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntMap& operator=(IntMap&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntMap* internal_default_instance() {
    return reinterpret_cast<const IntMap*>(
               &_IntMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IntMap& a, IntMap& b) {
    a.Swap(&b);
  }
  inline void Swap(IntMap* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntMap* New() const final {
    return CreateMaybeMessage<IntMap>(nullptr);
  }

  IntMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntMap& from);
  void MergeFrom(const IntMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mam.IntMap";
  }
  protected:
  explicit IntMap(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_seventh_2eproto);
    return ::descriptor_table_seventh_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kIntstringFieldNumber = 1,
  };
  // map<int32, string> intstring = 1;
  int intstring_size() const;
  private:
  int _internal_intstring_size() const;
  public:
  void clear_intstring();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, std::string >&
      _internal_intstring() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, std::string >*
      _internal_mutable_intstring();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, std::string >&
      intstring() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, std::string >*
      mutable_intstring();

  // @@protoc_insertion_point(class_scope:mam.IntMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      IntMap_IntstringEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int32, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > intstring_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seventh_2eproto;
};
// -------------------------------------------------------------------

class IntObjMap_IntobjmapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IntObjMap_IntobjmapEntry_DoNotUse, 
    std::string, ::mam::SubType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IntObjMap_IntobjmapEntry_DoNotUse, 
    std::string, ::mam::SubType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  IntObjMap_IntobjmapEntry_DoNotUse();
  explicit IntObjMap_IntobjmapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const IntObjMap_IntobjmapEntry_DoNotUse& other);
  static const IntObjMap_IntobjmapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const IntObjMap_IntobjmapEntry_DoNotUse*>(&_IntObjMap_IntobjmapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mam.IntObjMap.IntobjmapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_seventh_2eproto);
    return ::descriptor_table_seventh_2eproto.file_level_metadata[7];
  }

  public:
};

// -------------------------------------------------------------------

class IntObjMap PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mam.IntObjMap) */ {
 public:
  inline IntObjMap() : IntObjMap(nullptr) {}
  virtual ~IntObjMap();

  IntObjMap(const IntObjMap& from);
  IntObjMap(IntObjMap&& from) noexcept
    : IntObjMap() {
    *this = ::std::move(from);
  }

  inline IntObjMap& operator=(const IntObjMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntObjMap& operator=(IntObjMap&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntObjMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntObjMap* internal_default_instance() {
    return reinterpret_cast<const IntObjMap*>(
               &_IntObjMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IntObjMap& a, IntObjMap& b) {
    a.Swap(&b);
  }
  inline void Swap(IntObjMap* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntObjMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntObjMap* New() const final {
    return CreateMaybeMessage<IntObjMap>(nullptr);
  }

  IntObjMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntObjMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntObjMap& from);
  void MergeFrom(const IntObjMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntObjMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mam.IntObjMap";
  }
  protected:
  explicit IntObjMap(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_seventh_2eproto);
    return ::descriptor_table_seventh_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kIntobjmapFieldNumber = 1,
  };
  // map<string, .mam.SubType> intobjmap = 1;
  int intobjmap_size() const;
  private:
  int _internal_intobjmap_size() const;
  public:
  void clear_intobjmap();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mam::SubType >&
      _internal_intobjmap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mam::SubType >*
      _internal_mutable_intobjmap();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mam::SubType >&
      intobjmap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mam::SubType >*
      mutable_intobjmap();

  // @@protoc_insertion_point(class_scope:mam.IntObjMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      IntObjMap_IntobjmapEntry_DoNotUse,
      std::string, ::mam::SubType,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > intobjmap_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seventh_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Digimon

// double x_d = 1;
inline void Digimon::clear_x_d() {
  x_d_ = 0;
}
inline double Digimon::_internal_x_d() const {
  return x_d_;
}
inline double Digimon::x_d() const {
  // @@protoc_insertion_point(field_get:mam.Digimon.x_d)
  return _internal_x_d();
}
inline void Digimon::_internal_set_x_d(double value) {
  
  x_d_ = value;
}
inline void Digimon::set_x_d(double value) {
  _internal_set_x_d(value);
  // @@protoc_insertion_point(field_set:mam.Digimon.x_d)
}

// float x_f = 2;
inline void Digimon::clear_x_f() {
  x_f_ = 0;
}
inline float Digimon::_internal_x_f() const {
  return x_f_;
}
inline float Digimon::x_f() const {
  // @@protoc_insertion_point(field_get:mam.Digimon.x_f)
  return _internal_x_f();
}
inline void Digimon::_internal_set_x_f(float value) {
  
  x_f_ = value;
}
inline void Digimon::set_x_f(float value) {
  _internal_set_x_f(value);
  // @@protoc_insertion_point(field_set:mam.Digimon.x_f)
}

// int64 x_i64 = 3;
inline void Digimon::clear_x_i64() {
  x_i64_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Digimon::_internal_x_i64() const {
  return x_i64_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Digimon::x_i64() const {
  // @@protoc_insertion_point(field_get:mam.Digimon.x_i64)
  return _internal_x_i64();
}
inline void Digimon::_internal_set_x_i64(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  x_i64_ = value;
}
inline void Digimon::set_x_i64(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_x_i64(value);
  // @@protoc_insertion_point(field_set:mam.Digimon.x_i64)
}

// uint64 x_ui64 = 4;
inline void Digimon::clear_x_ui64() {
  x_ui64_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Digimon::_internal_x_ui64() const {
  return x_ui64_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Digimon::x_ui64() const {
  // @@protoc_insertion_point(field_get:mam.Digimon.x_ui64)
  return _internal_x_ui64();
}
inline void Digimon::_internal_set_x_ui64(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  x_ui64_ = value;
}
inline void Digimon::set_x_ui64(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_x_ui64(value);
  // @@protoc_insertion_point(field_set:mam.Digimon.x_ui64)
}

// int32 x_i32 = 5;
inline void Digimon::clear_x_i32() {
  x_i32_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Digimon::_internal_x_i32() const {
  return x_i32_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Digimon::x_i32() const {
  // @@protoc_insertion_point(field_get:mam.Digimon.x_i32)
  return _internal_x_i32();
}
inline void Digimon::_internal_set_x_i32(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_i32_ = value;
}
inline void Digimon::set_x_i32(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x_i32(value);
  // @@protoc_insertion_point(field_set:mam.Digimon.x_i32)
}

// uint32 x_ui32 = 6;
inline void Digimon::clear_x_ui32() {
  x_ui32_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Digimon::_internal_x_ui32() const {
  return x_ui32_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Digimon::x_ui32() const {
  // @@protoc_insertion_point(field_get:mam.Digimon.x_ui32)
  return _internal_x_ui32();
}
inline void Digimon::_internal_set_x_ui32(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  x_ui32_ = value;
}
inline void Digimon::set_x_ui32(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_x_ui32(value);
  // @@protoc_insertion_point(field_set:mam.Digimon.x_ui32)
}

// bool x_bl = 7;
inline void Digimon::clear_x_bl() {
  x_bl_ = false;
}
inline bool Digimon::_internal_x_bl() const {
  return x_bl_;
}
inline bool Digimon::x_bl() const {
  // @@protoc_insertion_point(field_get:mam.Digimon.x_bl)
  return _internal_x_bl();
}
inline void Digimon::_internal_set_x_bl(bool value) {
  
  x_bl_ = value;
}
inline void Digimon::set_x_bl(bool value) {
  _internal_set_x_bl(value);
  // @@protoc_insertion_point(field_set:mam.Digimon.x_bl)
}

// string x_str = 8;
inline void Digimon::clear_x_str() {
  x_str_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Digimon::x_str() const {
  // @@protoc_insertion_point(field_get:mam.Digimon.x_str)
  return _internal_x_str();
}
inline void Digimon::set_x_str(const std::string& value) {
  _internal_set_x_str(value);
  // @@protoc_insertion_point(field_set:mam.Digimon.x_str)
}
inline std::string* Digimon::mutable_x_str() {
  // @@protoc_insertion_point(field_mutable:mam.Digimon.x_str)
  return _internal_mutable_x_str();
}
inline const std::string& Digimon::_internal_x_str() const {
  return x_str_.Get();
}
inline void Digimon::_internal_set_x_str(const std::string& value) {
  
  x_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Digimon::set_x_str(std::string&& value) {
  
  x_str_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mam.Digimon.x_str)
}
inline void Digimon::set_x_str(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  x_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mam.Digimon.x_str)
}
inline void Digimon::set_x_str(const char* value,
    size_t size) {
  
  x_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mam.Digimon.x_str)
}
inline std::string* Digimon::_internal_mutable_x_str() {
  
  return x_str_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Digimon::release_x_str() {
  // @@protoc_insertion_point(field_release:mam.Digimon.x_str)
  return x_str_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Digimon::set_allocated_x_str(std::string* x_str) {
  if (x_str != nullptr) {
    
  } else {
    
  }
  x_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), x_str,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mam.Digimon.x_str)
}

// bytes x_bs = 9;
inline void Digimon::clear_x_bs() {
  x_bs_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Digimon::x_bs() const {
  // @@protoc_insertion_point(field_get:mam.Digimon.x_bs)
  return _internal_x_bs();
}
inline void Digimon::set_x_bs(const std::string& value) {
  _internal_set_x_bs(value);
  // @@protoc_insertion_point(field_set:mam.Digimon.x_bs)
}
inline std::string* Digimon::mutable_x_bs() {
  // @@protoc_insertion_point(field_mutable:mam.Digimon.x_bs)
  return _internal_mutable_x_bs();
}
inline const std::string& Digimon::_internal_x_bs() const {
  return x_bs_.Get();
}
inline void Digimon::_internal_set_x_bs(const std::string& value) {
  
  x_bs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Digimon::set_x_bs(std::string&& value) {
  
  x_bs_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mam.Digimon.x_bs)
}
inline void Digimon::set_x_bs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  x_bs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mam.Digimon.x_bs)
}
inline void Digimon::set_x_bs(const void* value,
    size_t size) {
  
  x_bs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mam.Digimon.x_bs)
}
inline std::string* Digimon::_internal_mutable_x_bs() {
  
  return x_bs_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Digimon::release_x_bs() {
  // @@protoc_insertion_point(field_release:mam.Digimon.x_bs)
  return x_bs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Digimon::set_allocated_x_bs(std::string* x_bs) {
  if (x_bs != nullptr) {
    
  } else {
    
  }
  x_bs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), x_bs,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mam.Digimon.x_bs)
}

// map<string, double> x_map = 10;
inline int Digimon::_internal_x_map_size() const {
  return x_map_.size();
}
inline int Digimon::x_map_size() const {
  return _internal_x_map_size();
}
inline void Digimon::clear_x_map() {
  x_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Digimon::_internal_x_map() const {
  return x_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Digimon::x_map() const {
  // @@protoc_insertion_point(field_map:mam.Digimon.x_map)
  return _internal_x_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Digimon::_internal_mutable_x_map() {
  return x_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Digimon::mutable_x_map() {
  // @@protoc_insertion_point(field_mutable_map:mam.Digimon.x_map)
  return _internal_mutable_x_map();
}

// .mam.ShouldType x_enum = 11;
inline void Digimon::clear_x_enum() {
  x_enum_ = 0;
}
inline ::mam::ShouldType Digimon::_internal_x_enum() const {
  return static_cast< ::mam::ShouldType >(x_enum_);
}
inline ::mam::ShouldType Digimon::x_enum() const {
  // @@protoc_insertion_point(field_get:mam.Digimon.x_enum)
  return _internal_x_enum();
}
inline void Digimon::_internal_set_x_enum(::mam::ShouldType value) {
  
  x_enum_ = value;
}
inline void Digimon::set_x_enum(::mam::ShouldType value) {
  _internal_set_x_enum(value);
  // @@protoc_insertion_point(field_set:mam.Digimon.x_enum)
}

// .mam.SubType st = 12;
inline bool Digimon::_internal_has_st() const {
  return this != internal_default_instance() && st_ != nullptr;
}
inline bool Digimon::has_st() const {
  return _internal_has_st();
}
inline void Digimon::clear_st() {
  if (GetArena() == nullptr && st_ != nullptr) {
    delete st_;
  }
  st_ = nullptr;
}
inline const ::mam::SubType& Digimon::_internal_st() const {
  const ::mam::SubType* p = st_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mam::SubType*>(
      &::mam::_SubType_default_instance_);
}
inline const ::mam::SubType& Digimon::st() const {
  // @@protoc_insertion_point(field_get:mam.Digimon.st)
  return _internal_st();
}
inline void Digimon::unsafe_arena_set_allocated_st(
    ::mam::SubType* st) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(st_);
  }
  st_ = st;
  if (st) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mam.Digimon.st)
}
inline ::mam::SubType* Digimon::release_st() {
  
  ::mam::SubType* temp = st_;
  st_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mam::SubType* Digimon::unsafe_arena_release_st() {
  // @@protoc_insertion_point(field_release:mam.Digimon.st)
  
  ::mam::SubType* temp = st_;
  st_ = nullptr;
  return temp;
}
inline ::mam::SubType* Digimon::_internal_mutable_st() {
  
  if (st_ == nullptr) {
    auto* p = CreateMaybeMessage<::mam::SubType>(GetArena());
    st_ = p;
  }
  return st_;
}
inline ::mam::SubType* Digimon::mutable_st() {
  // @@protoc_insertion_point(field_mutable:mam.Digimon.st)
  return _internal_mutable_st();
}
inline void Digimon::set_allocated_st(::mam::SubType* st) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete st_;
  }
  if (st) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(st);
    if (message_arena != submessage_arena) {
      st = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, st, submessage_arena);
    }
    
  } else {
    
  }
  st_ = st;
  // @@protoc_insertion_point(field_set_allocated:mam.Digimon.st)
}

// repeated .mam.SubType rst = 13;
inline int Digimon::_internal_rst_size() const {
  return rst_.size();
}
inline int Digimon::rst_size() const {
  return _internal_rst_size();
}
inline void Digimon::clear_rst() {
  rst_.Clear();
}
inline ::mam::SubType* Digimon::mutable_rst(int index) {
  // @@protoc_insertion_point(field_mutable:mam.Digimon.rst)
  return rst_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mam::SubType >*
Digimon::mutable_rst() {
  // @@protoc_insertion_point(field_mutable_list:mam.Digimon.rst)
  return &rst_;
}
inline const ::mam::SubType& Digimon::_internal_rst(int index) const {
  return rst_.Get(index);
}
inline const ::mam::SubType& Digimon::rst(int index) const {
  // @@protoc_insertion_point(field_get:mam.Digimon.rst)
  return _internal_rst(index);
}
inline ::mam::SubType* Digimon::_internal_add_rst() {
  return rst_.Add();
}
inline ::mam::SubType* Digimon::add_rst() {
  // @@protoc_insertion_point(field_add:mam.Digimon.rst)
  return _internal_add_rst();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mam::SubType >&
Digimon::rst() const {
  // @@protoc_insertion_point(field_list:mam.Digimon.rst)
  return rst_;
}

// repeated int32 x_ia = 14;
inline int Digimon::_internal_x_ia_size() const {
  return x_ia_.size();
}
inline int Digimon::x_ia_size() const {
  return _internal_x_ia_size();
}
inline void Digimon::clear_x_ia() {
  x_ia_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Digimon::_internal_x_ia(int index) const {
  return x_ia_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Digimon::x_ia(int index) const {
  // @@protoc_insertion_point(field_get:mam.Digimon.x_ia)
  return _internal_x_ia(index);
}
inline void Digimon::set_x_ia(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  x_ia_.Set(index, value);
  // @@protoc_insertion_point(field_set:mam.Digimon.x_ia)
}
inline void Digimon::_internal_add_x_ia(::PROTOBUF_NAMESPACE_ID::int32 value) {
  x_ia_.Add(value);
}
inline void Digimon::add_x_ia(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_x_ia(value);
  // @@protoc_insertion_point(field_add:mam.Digimon.x_ia)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Digimon::_internal_x_ia() const {
  return x_ia_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Digimon::x_ia() const {
  // @@protoc_insertion_point(field_list:mam.Digimon.x_ia)
  return _internal_x_ia();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Digimon::_internal_mutable_x_ia() {
  return &x_ia_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Digimon::mutable_x_ia() {
  // @@protoc_insertion_point(field_mutable_list:mam.Digimon.x_ia)
  return _internal_mutable_x_ia();
}

// -------------------------------------------------------------------

// SubType

// int32 y_i32 = 1;
inline void SubType::clear_y_i32() {
  y_i32_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SubType::_internal_y_i32() const {
  return y_i32_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SubType::y_i32() const {
  // @@protoc_insertion_point(field_get:mam.SubType.y_i32)
  return _internal_y_i32();
}
inline void SubType::_internal_set_y_i32(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  y_i32_ = value;
}
inline void SubType::set_y_i32(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y_i32(value);
  // @@protoc_insertion_point(field_set:mam.SubType.y_i32)
}

// -------------------------------------------------------------------

// IntArray

// repeated int32 iarray = 1;
inline int IntArray::_internal_iarray_size() const {
  return iarray_.size();
}
inline int IntArray::iarray_size() const {
  return _internal_iarray_size();
}
inline void IntArray::clear_iarray() {
  iarray_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntArray::_internal_iarray(int index) const {
  return iarray_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntArray::iarray(int index) const {
  // @@protoc_insertion_point(field_get:mam.IntArray.iarray)
  return _internal_iarray(index);
}
inline void IntArray::set_iarray(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  iarray_.Set(index, value);
  // @@protoc_insertion_point(field_set:mam.IntArray.iarray)
}
inline void IntArray::_internal_add_iarray(::PROTOBUF_NAMESPACE_ID::int32 value) {
  iarray_.Add(value);
}
inline void IntArray::add_iarray(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_iarray(value);
  // @@protoc_insertion_point(field_add:mam.IntArray.iarray)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
IntArray::_internal_iarray() const {
  return iarray_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
IntArray::iarray() const {
  // @@protoc_insertion_point(field_list:mam.IntArray.iarray)
  return _internal_iarray();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
IntArray::_internal_mutable_iarray() {
  return &iarray_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
IntArray::mutable_iarray() {
  // @@protoc_insertion_point(field_mutable_list:mam.IntArray.iarray)
  return _internal_mutable_iarray();
}

// -------------------------------------------------------------------

// StArray

// repeated .mam.SubType sts = 1;
inline int StArray::_internal_sts_size() const {
  return sts_.size();
}
inline int StArray::sts_size() const {
  return _internal_sts_size();
}
inline void StArray::clear_sts() {
  sts_.Clear();
}
inline ::mam::SubType* StArray::mutable_sts(int index) {
  // @@protoc_insertion_point(field_mutable:mam.StArray.sts)
  return sts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mam::SubType >*
StArray::mutable_sts() {
  // @@protoc_insertion_point(field_mutable_list:mam.StArray.sts)
  return &sts_;
}
inline const ::mam::SubType& StArray::_internal_sts(int index) const {
  return sts_.Get(index);
}
inline const ::mam::SubType& StArray::sts(int index) const {
  // @@protoc_insertion_point(field_get:mam.StArray.sts)
  return _internal_sts(index);
}
inline ::mam::SubType* StArray::_internal_add_sts() {
  return sts_.Add();
}
inline ::mam::SubType* StArray::add_sts() {
  // @@protoc_insertion_point(field_add:mam.StArray.sts)
  return _internal_add_sts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mam::SubType >&
StArray::sts() const {
  // @@protoc_insertion_point(field_list:mam.StArray.sts)
  return sts_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// IntMap

// map<int32, string> intstring = 1;
inline int IntMap::_internal_intstring_size() const {
  return intstring_.size();
}
inline int IntMap::intstring_size() const {
  return _internal_intstring_size();
}
inline void IntMap::clear_intstring() {
  intstring_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, std::string >&
IntMap::_internal_intstring() const {
  return intstring_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, std::string >&
IntMap::intstring() const {
  // @@protoc_insertion_point(field_map:mam.IntMap.intstring)
  return _internal_intstring();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, std::string >*
IntMap::_internal_mutable_intstring() {
  return intstring_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, std::string >*
IntMap::mutable_intstring() {
  // @@protoc_insertion_point(field_mutable_map:mam.IntMap.intstring)
  return _internal_mutable_intstring();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// IntObjMap

// map<string, .mam.SubType> intobjmap = 1;
inline int IntObjMap::_internal_intobjmap_size() const {
  return intobjmap_.size();
}
inline int IntObjMap::intobjmap_size() const {
  return _internal_intobjmap_size();
}
inline void IntObjMap::clear_intobjmap() {
  intobjmap_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mam::SubType >&
IntObjMap::_internal_intobjmap() const {
  return intobjmap_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mam::SubType >&
IntObjMap::intobjmap() const {
  // @@protoc_insertion_point(field_map:mam.IntObjMap.intobjmap)
  return _internal_intobjmap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mam::SubType >*
IntObjMap::_internal_mutable_intobjmap() {
  return intobjmap_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mam::SubType >*
IntObjMap::mutable_intobjmap() {
  // @@protoc_insertion_point(field_mutable_map:mam.IntObjMap.intobjmap)
  return _internal_mutable_intobjmap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mam

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mam::ShouldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mam::ShouldType>() {
  return ::mam::ShouldType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_seventh_2eproto
