
## 说明
- 选择排序就是从待排序的元素序列中选择关键字最小或最大的元素，将其放在已排序元素序列的最前面或最后面，其余的元素构成新的待排序元素序列，并从待排序元素序列中选择关键字最小的元素，将其放在已排序元素序列的最前面或最后面。依此类推，直到待排序元素序列中没有待排序的元素。

## 简单选择排序
- 基本思想是: 假设待排序的元素序列有 n 个，第一趟排序经过 n - 1 次比较，从 n 个元素序列中选择关键字最小的元素，并将其放在元素序列的最前面，即第一个位置。第二趟排序从剩余的 n - 1 个元素中，经过 n - 2 次比较，选择关键字最小的元素，将其放在第二个位置。依此类推，直到没有待比较的元素。
- 时间复杂度 O(n^2)，空间复杂度 O(1)。
- 稳定排序。

## 堆排序
- 堆排序是利用了二叉树的树形结构进行排序，按照完全二叉树的编号次序，将元素序列的关键字依次存放在相应的结点。然后从叶子结点开始，从互为兄弟的两个结点中（没有兄弟结点除外），选择一个较大(或较小)者与其双亲结点比较，如果该结点大于(或小于)双亲结点，则将两者交换，使较大(或较小)者成为双亲结点。将所有的结点都做类似操作，直到根结点为止。这时，根结点的元素值的关键字最大(或最小)。
- 一个是非叶子结点的元素值不小于其孩子结点的值，这样的堆称为大顶堆。另一个是非叶子结点的元素值不大于其孩子结点的元素值，这样的堆称为小顶堆。
- 如果将堆中的根结点(堆顶)输出之后，再将剩余的 n - 1 个结点的元素值重新建立一个堆，则新堆的堆顶元素值是次大（或次小）值，将该堆顶元素输出。然后将剩余的 n - 2 个结点的元素值重新建立一个堆，反复执行以上操作，直到堆中没有结点，就构成了一个有序序列， 这样的重复建堆并输出堆顶元素的过程称为堆排序。

### 建堆
- 堆排序的过程就是建立堆和不断调整，使剩余结点构成新堆的过程。假设将待排序的元素的关键字存放在数组 a 中，第 1 个元素的关键字 a[0] 表示二叉树的根结点，剩下的元素的关键字 a[1...n] 分别与二叉树中的结点按照层次从左到右一一对应。例如，a[0]的左孩子结点存放在 a[1] 中，右孩子结点存放在 a[2] 中，a[i] 的左孩子结点存放在 a[2 * i + 1] 中，右孩子结点存放在 a[2 * i + 2)] 中。
- 如果是大顶堆，则有 a[i] >= a[2 * i + 1] 且 a[i] >= a[2 * i + 2)] (i=0,1,...,floor((n-1)/2))。如果是小顶堆，则有 a[i] <= a[2 * i + 1] 且 a[i] <= a[2 * i + 2)] (i=0,1,...,floor((n-1)/2))。
- 建大顶堆思想: 从位于元素序列中的最后一个非叶子结点，即索引为 floor((n-1)/2) 的元素形如，逐层比较，直到根结点为止。假设当前结点的索引为 i, 则当前元素为 a[i]，其左右孩子结点元素分别为 a[2 * i + 1] 和 a[2 * i + 2]，将两孩子结点较大值与 a[i] 比较，如果孩子结点元素值大于当前结点值，则交换两者；否则不进行交换。逐层向上执行此操作，直到根结点，这样就建立了一个大顶堆。建立小顶堆的算法与此类似。

### 调整堆
- 建立一个大顶堆完成后，根结点是所有待排序元素的最大值，当输出堆顶元素后，对其余待排元素继续建堆。
- 当堆顶元素输出后，可以将堆顶元素与堆中最后一个元素交换，接下来需要调整的元素序列就是 a[0...n-1]这里，除了堆顶元素外，剩下的元素本身就具有 a[i] >= a[2 * i + 1] 且 a[i] >= a[2 * i + 2)] 的性质。所以可以从根结点开始，如果左右子结点元素值大于父母结点值，选择较大的一个进行交换。依次向下重复此操作，直到叶子结点不存在，就完成了堆的调整，构成了一个新堆。
