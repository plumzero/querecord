
递归中，每运行到一个 return 语句，就是一次退栈。

> 对于循环问题，可以多尝试递归思维。

递归和分治很像，都是将一个复杂的算法问题进行分解，让规模越来越小，最终使子问题容易求解。

简单来说，对程序设计人员的实现而言，"函数"(或称为子程序)不单纯只是能够被其他函数调用(或引用)的程序单元，在某些程序设计语言中还提供了自己调用自己的功能，这两种调用的功能就是所谓的"递归"。

它至少要定义两个条件，包括一个可以反复执行的递归过程与一个跳出执行过程的出口。

"尾递归" 就是函数或子程序的最后一条语句为递归调用，因为每次调用后，再回到前一次调用的第一条语句就是 return 语句，所以不需要再进行任何运算工作了。

> 尾递归和循环语句之间可以互相转化，但非尾递归无法转化为循环。

阶乘运算就是一个尾递归过程，其实现如下:
```cpp
	int fact(int n)
	{
		if (n == 0)
			return 1;
		return n * fact(n - 1);
	}
```
for 结构中有三个表达式语句，分别是初始化语句、迭代条件、以及最后的迭代因子。

上面的尾递归过程:
- n 可以作为初始化语句
- 尾递归中，"n == 0" 是退出递归的条件，但是在 for 结构中，应该改为继续迭代的条件，不妨改为 "n != 0"
- 迭代因子就是每次对 n 自减一次

另外，对于每次计算的结果，在递归中是由程序栈返回保存的。在化成循环后，程序员需要自己保存每次计算的值。

所以化成循环结构为:
```cpp
	int fact(int n)
	{
		int prod = 1;
		for (; n != 0; n--) {
			prod *= n;
		}
		return n;
	}
```

当然，我们也可以通过栈来模拟递归函数的调用。对栈的操作有入栈和出栈两种，其中入栈的元素是参数，出栈的元素是返回值。

以 5! 的计算为例。

可以定义一个一维数组栈，首先入栈的元素是 5，然后是 4，最后是 1。之后出栈元素 1，计算结果并保存，之后出栈元素 2，直到 5 。

也可以定义一个 n × 2 维数组，n 表示栈的层数，每层两个空间，一个用来存储入参，另一个用来存储计算得到的返回值。其实同一维栈类似。入栈时压入参数，出栈时弹出返回值。


- [阶乘程序示例](fact.cpp)
- [斐波那契程序示例](fibo.cpp)
- [汉诺塔程序示例](hanoi.c)
