
### 顺序查找

一般适用于对少量、无规则的数据集进行查找。

### 二分查找

二分查找，是将有序或局部有序的序列的数据从中间分成前后两个子表，通过不断缩小目标值的检索范围进行检索的方法。

使用二分查找时需要定义左右两个游标，而左右游标必收敛于某个点。

比较普遍的一种写法是首先定义左右两个游标，分别指向序列中最左边和最右边的两个元素，两个游标相向移动。如果能够找到符合条件的某个点，那必收敛于该点，否则两个游标在相遇后必然向序列两端发散。所以循环的终止或返回条件应该是收敛于某点或者即将发散。

以这个思路，代码大致如下:
```cpp
    a[] = ...;
    left = 0, right = len - 1, mid;
    while (left <= right) {
        mid = left + (right - left) / 2;
        if (a[mid]右移条件充分) {
            left = mid + 1;
        } else {    // 否则左移
            right = mid - 1;
        }
    }
    if (a[mid]符合条件) {
        return a[mid];
    }
    return -1;
```

另外还有一种蓝红定界法。将序列根据是否符合某个条件分为蓝红两个区域，不妨左蓝右红。同时定义两个游标。开始时左游标指向蓝色区域左边界-1，右游标指向红色区域右边界+1。

然后根据条件相向移动，同时保证左游标只在蓝色区域内移动，而右游标只在红色区域内移动。所以它的循环终止条件是左游标指向蓝色区域的最后一个元素，并且右游标指向红色区域的第一个元素。

代码如下:
```cpp
    left = -1, right = len, mid;
    while (left + 1 != right) {
        mid = left + (right - left) / 2;
        if IsBlue(mid) {
            left = mid;
        } else {
            right = mid;
        }
    }
    return left or right;   // 根据条件返回
```

这种蓝红定界法常常用于寻找某个首先出现或最后出现的某个元素。比如在一个升序序列中寻找最后一个小于 5 的元素，就可以将条件定为:
```cpp
    if (a[mid] < 5) {
        left = mid;
    } else {
        right = mid;
    }

    return left;    // 整个蓝色区域内的元素都是小于 5 的，而 left 最终会指向蓝色区域的最后一个符合条件的元素
```
如果要在一个序列中寻找第一个大于 5 的元素，就应该这样写:
```cpp
    if (a[mid] < 5) {
        left = mid;
    } else {
        right = mid;
    }

    return right;   // 和上面的相比，只是返回值变了。整个红色区域的元素都是大于 5 的，而 right 最终会指向红色区域的第一个符合条件的元素
```

### 哈希查找

略

### 插值查找

略

### 二叉搜索树

略
