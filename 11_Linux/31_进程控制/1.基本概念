

////////////////////////////// 内核 //////////////////////////////

内核的职责
  进程调试
  内存管理
  提供了文件系统
  创建和终止进程
  对设备的访问
  联网
  提供系统调用应用编程接口

内核态和用户态
  CPU 执行的两种状态。与之对应，可将虚拟内存区域划分为用户空间部分或内核空间部分。
  
内核与进程
  1. 进程间彼此不能直接通信。进程本身无法创建出新进程，哪怕是"自行了断"都不行。进程也不能与计算机外接的输入或输
  出设备直接通信。
  2. 进程间的所有通信都要通过内核提供的通信机制来完成。响应进程发出的请求，内核会创建新的进程，终结现有进程。最
  后，由内核（特别是设备驱动程序）来执行与输入/输出设备之间的所有直接通信，按需与用户进程交互信息。

////////////////////////////// 文件 I/O 模型 //////////////////////////////

同一套系统调用(open(), read(), write(), close()等)所执行的 I/O 操作，可施之于所有文件类型，包括设备文件在内。

////////////////////////////// 进程 //////////////////////////////

执行进程时，内核会将程序代码载入虚拟内存，为程序变量分配空间，建立内核记帐数据结构，以记录与进程有关的各种信息（
比如，进程 ID、用户 ID、组 ID 以及终止状态等）。

每个进程都有一个当前工作目录（有时简称为进程工作目录或当前目录）。
可使用 cd 命令来改变 shell 的当前工作目录。

创建进程和执行程序
  1. 进程可使用系统调用 fork() 来创建一个新进程。调用 fork() 的进程被称为父进程，新创建的进程则被称为子进程。内核
  通过对父进程的复制来创建子进程。子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进
  程的"原版"内容。（在内存中标记为只读的程序文件段则由父、子进程共享。）
  2. 然后，子进程要么去执行与父进程共享代码段中的另一组不同函数，或者，更为常见的情况是使用系统调用 execve() 去加
  载并执行一个全新程序。 execve() 会销毁现有的文本段、数据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们。

进程 ID 和 父进程 ID
  每一进程都有一个唯一的整数型进程标识符(PID)。此外，每一进程还具有一个父进程标识符(PPID)属性，用以标识请求内核创建
  自己的进程 。
  
进程终止和终止状态
  1. 可以使用以下两种方式之一来终止一个进程：
     a. 进程可使用 _exit() 系统调用(或相关的 exit() 库函数)，请求退出；
     b. 向进程传递信号，将其"杀死"；
  2. 无论以何种方式退出，进程都会生成"终止状态"，一个非负小整数，可供父进程的 wait() 系统调用检测。
  3. 在调用 _exit() 的情况下，进程会指明自己的终止状态。若由信号来"杀死"进程，则会根据导致进程"死亡"的信号类型来设置
  进程的终止状态。（有时会将传递进 _exit() 的参数称为进程的"退出状态"，以示与终止状态有所不同，后者要么指传递给 
  _exit() 的参数值，要么表示"杀死"进程的信号。）
  4. 根据惯例，终止状态为 0 表示进程"功成身退"，非 0 则表示有错误发生。大多数 shell 会将前一执行程序的终止状态保存于
  shell 变量 $? 中。
  
init 进程
  1. 系统引导进，内核会创建一个名为 init 的特殊进程，即"所有进程之父"，该进程的相应程序文件为 /sbin/init。
  2. 系统的所有进程不是由 init（使用 fork()）"亲自"创建，就是由其后代进程创建。init 进程的进程号总为1， 且总以超级用
  户权限运行。谁（哪怕是超级用户）都不能"杀死" init 进程，只有关闭系统才能终止该进程。
  3. root 权限和 init 进程的区别：前者一般是具有 root 权限的用户(用户 id 为 0)，后者是一个进程。
  
环境列表
  1. 每个进程都有一个环境列表，即在进程用户空间内存中维护的一组环境变量。
  2. 由 fork() 创建的新进程，会继承父进程的环境副本。这也为子父子进程间通信提供了一种机制。
  3. 可以通过 exec() 族函数指定新环境并加以接收。
  
资源限制
  1. 每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用 setrlimit()，进程可为自己消耗的各类资源
  设定一个上限。
  2. 此类资源限制的每一项均有两个相关值: 软限制(soft limit)限制了进程可以消耗的资源总量，硬限制(hard limit)是软限制的
  调整上限。
  3. 非特权进程在针对特定资源调整软限制值时，可将其设置为 0 到相应硬限制值之间的任意值，但硬限制值只能调低，不能调高。
  4. 由 fork() 创建的新进程，会继承其父进程对资源限制的设置。
  5. 使用 ulimit 命令可调整 shell 的资源限制。shell 为执行命令所创建的子进程会继承上述资源限制。
  
////////////////////////////// 内存映射 //////////////////////////////

调用系统函数 mmap() 的进程，会在其虚拟地址空间中创建一个新的内存映射。

////////////////////////////// 进程间通信及同步 //////////////////////////////

Linux 进程间通信(IPC)机制:
  1. 信号(signal)，用来表示事件的发生
  2. 管道和 FIFO，用于在进程间传递数据
  3. 套接字
  4. 文件锁定
  5. 消息队列，用于在进程间交换消息（数据包）
  6. 信号量(semaphore)，用来同步进程动作
  7. 共享内存，允许两个及两个以上进程共享一块内存
  
////////////////////////////// 信号 //////////////////////////////

相比于 IPC ，信号机制在其他方面的应用更为普遍。
进程与信号
  1. 人们往往将信号称为"软件中断"。进程收到信号，就意味着某一事件或异常的发生。
  2. 内核、其他进程（只要具有相应的权限）或进程自身均可向进程发送信号。
  3. 发生下列情况时，内核可向进程发送信号:
     a. 用户键入中断字符(control-C)；
     b. 进程的子进程之一已经终止；
     c. 由进程设定的定时器已经到期；
     d. 进程尝试访问无效的内存地址；
  4. 在 shell 中，可使用 kill 命令向进程发送信号。在程序内部，系统调用 kill() 可提供相同的功能。
  5. 收到信号时，进程会根据信号采取如下动作之一：
     a. 忽略信号
     b. 被信号"杀死"
     c. 先挂起，之后再被专用信号唤醒
  6. 就大多数信号类型而言，程序可选择不采取默认的信号动作，而是忽略信号或者建立自己的信号处理器。
	 信号处理器是程序员定义的函数，会在进程收到信号时自动调用，根据信号的产生条件执行相应的动作。
	 
////////////////////////////// 会话、控制终端和控制进程 //////////////////////////////

1. 会话是指一组进程组（任务）。会话中的所有进程都具有相同的会话标识符（会话 ID）。
2. 会话首进程(session leader)是指创建会话的进程，其进程 ID 会成为会话 ID。
3. 会话都会与某个控制终端相关，使用会话最多的是支持任务控制的 shell 。通过远程终端工具(如 putty, SecureCRT)打开一
   个终端 ，即创建一个 shell 会话，shell 也是此会话的会话首进程。通过此 shell 创建的所有进程组与 shell 自身隶属于
   同一会话。
4. 打开控制终端会致使会话首进程成为终端的控制进程。一旦断开了与终端的连接（比如关闭了终端窗口），控制进程将会收到
   SIGHUP 信号。
5. 经过测试，关闭控制终端时，会话中进程组中的进程均会收到 SIGHUP 信号。

