许多程序需要开机启动。它们在Windows叫做"服务"（service），在Linux就叫做"守护进程"（daemon）。

ps -aux			//以BSD风格显示进程
	USER			PID			PPID		%CPU		TTY		%MEM		NI			VSZ				RSS				STAT
	进程所有者		进程ID		父进程		CPU占用		终端ID	内存占用	进程优先级	进程虚拟大小	页面文件占用	进程状态
	进程状态标志符含义
		D	不可中断									l	多线程，克隆线程
		S	处于休眠状态								X	死掉的进程
		s	包含子进程									<	高优先级
		T	停止或被追踪								N	低优先级
		Z	僵尸进程									L	有些页被锁进内存
		+	位于后台的进程组
		R	正在运行或在队列中的进程
ps -efH			//以System V风格显示进程

top
	动态显示当前耗费资源最多进程信息。
	top -n 2	更新2次后终止更新显示
	top	-d 3	每隔3秒进行一次更新
	top -p 139	显示进程号为139的进程信息
	top -n 2 -b > top.log	将更新显示2次的结果输入到名称为top.log的档案里
top命令交互按键
	N		进程ID排序（由大到小）
	s		改变两次刷新时间间隔（以秒为单位）
	S		切换到累积时间模式
	<space>	立即刷新
	M		按内存占用排序（由大到小）
	T		按时间/累积时间排序
	P		按CPU占用排序（由大到小）

swap空间的作用:
	当系统物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。
	这些被释放的空间可能来自一些很长时间没有什么操作的程序，可以将其临时保存到swap空间中，等到那些程序要运行时，再从swap中恢复保存的数据到内存中。
	需要注意的是，系统总是在物理内存不够时，才进行swap交换。
	
内核为每一个进程都分配了一个tast_struct数据结构，有时也称之为进程控制块（PCB）。
系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志，是接受内核调度的基本单位，记录着进程所占用的各项资源。
进程与PCB是一一对应的关系。

tast_struct结构体中比较重要的成员介绍：
	state	进程当前的运行状态
		TASK_RUNNING	可执行状态（或就绪状态）
		TASK_INTERRUPTIBLE	可中断的睡眠状态，可因某个信号的到来而被唤醒
		TASK_UNINTERRUPTIBLE	不可中断的睡眠状态，不会因信号或软中断而被唤醒
		TASK_STOPPED	挂起状态，主要用于调试。接收到SIGSTOP信号进入此状态，直到接收到SIGCONT信号才恢复到可执行状态
		TASK_ZOMBIE		僵尸状态，进程已死但其所占资源尚未回收
		TASK_DEAD	进程彻底结束
	policy	适用于本进程的调试策略，用以区分两种进程：实时进程和普通进程
	pid		进程标识符，也称进程号，唯一
	rt_priority		进程实时优先级，通常由用户指定和系统设置
	实际用户标识符uid和组标识符gid	用来标识进程属于哪个用户和用户组
	有效用户标识符euid和有效组标识符egid用来决定对文件的访问权限
	user	指针，代表着进程所属的用户
	
进程ID 0 是调度进程，常被称为交换进程。此进程不执行磁盘上程序，是内核一部分，也被称为系统进程。
进程ID 1 是init进程，在自举过程结束时由内核调用。决不会终止，是一个普通的用户进程，但以超级用户特权运行。

一个或多个进程合起来构成一个进程组，一个或多个进程组合起来构成一个会话。如此可对进程进行批量操作，如通过向某进程组发送信号来实现向组内所有进程发送信号。

获得进程ID
	pid_t getpid(void);		//返回系统当前进程的进程ID
	
创建进程，事实上是复制进程。
Linux系统中，新进程的产生分为两步，第一步是从父进程中复制出一个子进程，此子进程有自己的task_struct结构和系统空间堆栈，但与父进程共享其他所有资源。
	假如父进程打开了5个文件，则子进程也有打开这5个文件，且文件当前读/写指针也停留在相同地方。
Linux提供了两个系统调用进行进程复制：fork()函数和clone()函数。区别如下：
	fork()：	最基本资源全部复制，如tast_struct块、系统空间堆栈、页面表等，对父进程代码及全局变量则不需要复制，仅通过只读访问形式实现共享。
	clone():	选择性复制，没有复制的数据结构通过指针共享给子进程
系统调用vfork()也可进行复制，但实质创建出来的是线程而不是进程，因为它缺少进程所必要的独立的内存空间。

子进程创建后通过exec函数族进行系统调用。

pid_t fork(void);		//被调用一次，但返回两次。子进程先返回，之后将子进程ID返回给父进程。子进程返回0，父进程返回新的子进程的ID。
fork返回后，子进程和父进程都从调用fork函数的下一条语句开始执行。但哪个进程先执行不确定，可通过进程间通信实现进程间的相互同步。
fork出错两种可能原因：
	当前进程数已经达到了系统规定的上限，这时errno值被设置为EAGAIN	->如果出错，最有可能是这种
	系统内存不足，这时errno值被设置为ENOMEM
由fork创建的父子进程并不是数据共享的，是相互独立的。
	
pid_t vfork(void);	//返回值同fork
返回后，子进程先执行，父进程挂起，直到子进程调用exec或exit后，父子进程的执行次序才不再有限制。
由vfork创建出来的子进程与父进程是共享内存区的。

进程执行
Linux使用exec函数族执行新的程序，以使新的子进程完全代替原有的进程。
	int execl(const char *pathname, const char *arg, ...);
	int execlp(const char *filename, const char *arg, ...);
	int execle(const char *pathname, const char *arg, ..., char *const envp[]);
	int execv(const char *pathname, char *const argv[]);
	int execvp(const char *filename, char *const argv[]);
	int execve(const char *pathname, char *const argv[], char *const envp[]);	//一参：可执行程序完整路径 二参：传递的命令行参数 三参：传递的环境变量
6个函数返回值相同，若成功无返回值，若出错返回-1。
函数名中含有 l 的，其参数个数不定，参数由所调用程序的命令行参数列表组成，最后一个NULL表示结束。
函数名中带有 v 的，使用一个字符串数组指针argv指向参数列表，该字符串数组和含有字母 l 的函数中的参数列表完全相同，也同样以NULL结束。
函数名中带有 p 的，可自动在环境变量PATH指定的路径中搜索要执行的程序，一参filename表示可执行文件名。
函数名中带有 e 的，相比其它我一个envp，此字符串数组指针用于指定环境变量。
调用exec函数族最常见的错误：
	找不到文件或路径，此时errno被设置为ENOENT
	数组argv和envp忘记使用NULL结束，此时errno被设置为EFAULT
	没有对要执行文件的运行权限，此时errno被设置为EACCES
	
进程消亡
进程结束的方式有两种：
自然退出：exit()和_exit()
	void exit(int status);	//参数为0表示正常结束，否则表示出现错误
	void _exit(int status);	//同上
	区别：exit()函数在调用之前要检查文件的打开情况，把文件缓冲区内容写回文件；_exit()函数直接停止进程，清除其使用的内存空间，不对标准I/O作任何操作。
异常终止 ：abort()			//不推荐使用

进程等待
有时父进程需要停下来，也就是进入睡眠状态，等待子进程执行完成并结束，然后父进程再继续执行。
在一个进程调用了exit之后，该进程并非立即消失，而是留下一个称为僵尸进程的数据结构。这时的处理方法之一就是使用进程等待的系统调用wait和waitpid。
僵尸进程没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集。
	pid_d wait(int *status);
		参数status用来保存被收集（等待）进程退出时的状态，若成功，返回被等待进程ID，否则返回-1
		进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到这样一个已经变成僵尸的子进程，wait就会收集这个子
		进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait会一直阻塞在这里，直到有一个出现为止。
		pid = wait(NULL);	//单纯消灭僵尸进程
	pid_t waitpid(pid_t pid, int *status, int options);
		参一取值及	含义：
		pid > 0		只等待进程ID为pid的子进程，不管其他已经有多少子进程退出，只要指定的子进程没有结束，就一直等待下去
		pid = -1	等待任何一个子进程退出
		pid = 0		等待同一个进程组中的任何子进程，如果某一子进程已经加入了别的进程组，waitpid忽略其
		pid < -1	等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值
		参二选项
		#define WNOHANG 	0x00000001		//即使没有子进程退出，也会立即返回，不会等待下去
		#define WUNTRACED	0x00000002
		ret = waitpid(-1, NULL, 0);		//等同于调用wait
	
	pid_t wait3(int *status, int options, struct rusage * rusage);
	pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);
		wait3和wait4分别相当于wait和waitpid，其在waitpid的基础上增加了可以获取进程及其子进程所占resources的情况的功能。
		如果rusage不为NULL，则关于子进程执行时的相关信息将被写入该指针指向的缓冲区。

通常情况下，父进程调用fork()后要调用wait()。
pid = fork();
if (!pid)
{
	/*子进程*/
}
else
{
	/*父进程*/
	wait(NULL);
}

如果父进程因执行了wait()调用而处于睡眠状态，那么子进程执行exit()会重新
启动父进程运行。

除了使用exit()来终止进程外，当进程运行完其程序到达main()函数末时，进程会
自动终止。当进程在main()函数内执行一个return语句时，它也会终止。

子进程尚未终止时，父进程却终止了。一般允许父进程结束，并把它的子进程交归
系统的初始化进程。

进程的属性
进程标识符
	利用系统调用getpid可以得到程序本身的进程标识符。
	利用系统调用getppid可以得到调用进程的父进程的标识符。
进程的组标识符
	进程最初是通过fork()和exec调用来继承其进程组标识符。但是，进程可以
	使用系统调用setpgrp()，自己形成一个新的组。
	setpgrp()的返回值newpg是新的进程组标识符，即调用进程的进程标识符。它所
	建立的所有进程，将继承newpg中的进程组标识符。
	一个进程可以用系统调用getpgrp()来获得其当前进程标识符。
进程的有效标识符
	它们被用来确定一个用户能否访问某个确定的文件。通常，它们与实际用户标识
	符和实际组标识符是一致的。
进程优先级
	系统以整型变量nice来决定一个特定进程可得到的CPU时间的比例。Nice的值从
	零至其最大值。进程的优先数越大，其优先权就越低。普通进程可以使用系统
	调用nice()来降低它的优先权，以把更多的资源分给其他进程。

写时复制技术
如果旧进程的某些虚拟内存在物理内存中，而有些在交换文件中，那么虚拟内存的复制将
会非常困难和费时。Linux采用了称为写时复制的技术，只有当两个进程中的任意一个向
虚拟内存中写入数据时才复制相应的虚拟内存，而没有写入的任何内存页均可以在两个进
程之间共享。

Linux进程命令
(1)crontab命令
作用：用于安装、删除或者列出用于驱动cron后台进程的任务表。然后，该配置由cron守
护进程在设定的时间执行。
格式：	crontab [-u user] 文件
	crontab [-u user] {-e | -l | -r}
选项：
	-e：执行文字编辑器来设定时程表
	-r：删除目前的时程表
	-l：列出目前的时程表
	[-u user]：指定要设置的用户名称
(2)ps命令
作用：主要查看系统中进程的状态
格式：ps [选项]
选项：
	-A：显示系统中所有进程的信息
	-e：显示所有进程的信息
	-f：显示进程的所有信息
	-l：以长格式显示进程信息
	-r：只显示正在运行的进程
	-u：显示面向用户的格式
	-x：显示所有非控制终端上的进程信息
	-p：显示由进程ID指定的进程的信息
	-t：显示指定终端上的进程的信息
(3)top命令
作用：用来显示系统当前的进程状况
格式：top [选项]
选项：
	d：指定更新的间隔，以秒计算
	q：没有任何延迟的更新
	c：显示进程的完整路径与名称
	S：累积模式，会将已完成或消失的子进程的CPU时间累积起来
	s：安全模式
	i：不显示任何闲置或无用的进程
	n：显示更新的次数，完成后将退出top
(4)at命令
作用：在指定时刻执行指定的命令序列
格式：at [-V][-q x][-f file][-m]time
选项：
	-V：显示作业将被执行的时间
	-q：可选队列名称
	-f：从文件中读取命令或Shell脚本，而非在提示后指定它们
	-m：执行完作业后发送电子邮件到用户
	time：设定作业执行的时间
(5)bg命令
作用：使一个被挂起的进程在后台执行
格式：bg
(6)fg命令
作用：使一个被挂起的进程在前台执行
格式：fg -[job-spec]
[job-spec]：后台任务号码
(7)nohup命令
作用：确保执行程序能在用户退出系统后继续工作
格式：nohup 命令
(8)pstree命令
作用：列出当前的进程，以及它们的树状结构
格式：pstree [选项][pid|usr]
选项：
	-a：显示执行程序的命令与完整参数
	-c：取消同名程序，合并显示
	-h：对输出结果进行处理，高亮显示正在执行的程序
	-l：长格式显示
	-n：以PID大小排序
	-p：显示PID
	-u：显示UID信息
(9)pgrep命令
作用：查找当前运行的进程，并列出匹配给定条件的进程的pid，所有的条件都必须匹配
才会被列出
格式：pgrep [选项][程序名]
选项：
	-l：列出程序名和进程ID
	-o：进程起始的ID
	-n：进程终止的ID
(10)chkconfig命令
作用：检查，设置系统的各种服务
格式：chkconfig [--add][--del][--list][系统服务] 或
      chkconfig [--level<等级代号>][系统服务][on/off/reset]
选项：
	--add：增加指定系统服务
	--del：删除指定系统服务
	--level<等级代号>：指定读系统服务要在哪一个执行等级中开启或关闭
(11)jobs命令
作用：显示后台任务的执行情况
格式：jobs [选项][jobspec...]
选项：
	-l：长输出格式，显示全部内容
	-n：不输出信息
	-p：只输出进程号
	-r：只输出运行的进程
	[jobspec]：后台任务号码
(12)sleep命令
(13)kill命令
(14)nice命令
作用：可以改变程序执行的优先权等级
格式：nice [-n <优先级等级>][--help][--version][命令]
选项：
	-n <优先级等级>：设置欲执行的命令的优先权等级。等级的范围为-20~19，其
	中，-20为最高，19为最低
	--help：在线帮助
	通常，普通应用程序优先权值都为零，较高的优先权启动和运行速度会更快。但
	普通用户只能在0~19之间调整应用程序的优先权，只有超级用户有权调整更高的
	优先权（-20~19之间）。	
(15)renice命令
作用：允许用户修改一个正在运行的进程的优先权
格式：renice priority [[-p]pids][[-g]pgrps][[-u]users]
选项：
	priority：优先等级
	-p pids：改变程序优先权等级
	-g pgrps：使用程序群组名称，修改所有隶属于该程序群组的程序的优先权
	-u user：指定用户名称，修改所有隶属于该用户的程序的优先权
	等级范围为-20~19，注意事项见(14)

与进程管理相关的系统调用
(1)系统调用chdir
	int chdir(const char *path);
作用：改变当前工作目录。参数是要转去的路径。
(2)系统调用setsid
	pid_t setsid(void);
作用：调用后，调用进程会成立一个新的会话，并自任该会话的组长。
(3)系统调用umask
	mode_t umask(mode_t mask);
作用：设定一个文件权限掩码，用户可以用它来屏蔽某些权限。