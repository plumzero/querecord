


信号
1. 信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。
2. 信号事件的发生有两个来源：第一，硬件来源，如按下了 Delete 键或者鼠标点击等，通常产生中断信号(
   SIGINT)或者其他硬件故障；第二，软件来源，如使用系统调用或者命令发出信号。最常用的发送信号的系
   统函数是 kill, raise, alarm, setitimer, sigation 和 sigqueue 等函数，软件来源还包括一些非法运
   算符等操作。
3. 信号与进程
   1) 传递的信号决定了当前进程的配置。
   2) 进程可以通过 sigaction 或 signal 改变信号的配置。其中 signal 在建立信号处理句柄
   (signal handler)时较不轻便。
   3) 子进程通过 fork 继承父进程的信号配置。
   4) 在执行 execve 过程中，被处理的信号配置被重置为缺省时的状态，被忽略的信号配置则保存不变。
4. 信号的挂起与阻塞
   1) 系统在 task_struct 结构中利用两个字分别记录当前挂起的信号及当前阻塞的信号。挂起的信号指尚
   未进行处理的信号，阻塞的信号是指进程当前不处理的信号。
   2) 除了 SIGKILL 和 SIGSTOP 信号外，所有的信号均可以被阻塞，信号的阻塞可以通过系统调用实现。
   3) 每个进程的 task_struct 结构中还包含了一个指向 sigaction 结构数组的指针，该结构数组中的信息
   实际指定了进程处理所有信号的方式。如果某个 sigaction 结构中包含有处理信号的例程地址，则由该处
   理例程处理该信号；反之，则根据结构中的一个标志或者内核进行默认处理，或者只忽略该信号。
   4) 通过系统调用，进程可以修改 sigaction 结构数组的信息，从而指定进程处理信号的方式。
5. 因信号处理句柄而导致的系统调用和库函数的中断
   1) 系统调用或库函数调用被阻塞时，如果信号处理句柄被调用，则:
     ① 信号处理句柄返回时，调用会自动重启，或者 
     ② 调用失败，并将 errno 设置为 EINTR。
   2) 对一些阻塞函数调用过程中因信号传递而调用信号处理句柄产生中断时，如果设置 SA_RESTART 时，阻塞
   调用会在信号处理句柄返回时自动重启。否则调用失败，并设置 EINTR。
   3) 一些阻塞函数
     ① read readv write writev ioctl 等阻塞函数在"慢"设备上的调用。
	 ② open, 如果可以阻塞的话(如打开一个 FIFO 时)
	 ③ 套接字接口(设置超时时): accept connect recv recvfrom recvmmsg recvmsg send sendto sendmsg
   4) 慢设备定义
     "慢"设备是 I/O 调用可能无限期阻塞的设备，如终端，管道，套接字等。如果信号处理句柄在进行中断处
	 理时，慢设备上的 I/O 调用已经传输了一些数据，则该调用将返回成功状态。
     注意: 本地磁盘不是慢设备，因为其I/O操作无法被信号中断。  
6. 因停止信号而导致的系统调用和库函数的中断
   1) Linux 系统下，某个因暂停信号而停止的进程（通过SIGCONT）恢复后，即使此时没有信号处理句柄，某些阻
   塞接口也会失败(此时 errno 设置为 EINTR)。
   2) POSIX.1 没有对这种行为进行处理，而这种行为在其他系统并不会发生。
   3) Linux 下，以下接口会显示上述的行为：
   "Input" 套接字接口: 通过 setsockopt 为套接字设置超时(SO_RCVTIMEO)时。表现函数有 accept, recv, 
   recvfrom, recvmmsg, recvmsg 。
   "Output" 套接字接口: 通过 setsockopt 为套接字设置超时(SO_RCVTIMEO)时。表现函数有 connect, send, 
   sendto, sendmsg(设置 SO_SNDTIMEO 时)。	 
7. 用户进程对信号的响应有 3 种方式
   ① 执行默认操作。Linux 对每种信号都规定了默认操作。
   ② 捕捉信号。定义信号处理函数，当信号发生时，执行相应的处理函数。
   ③ 忽略信号。当不希望接收到的信号对进程执行产生影响，而让进程继续执行时，可以忽略该信号，即不
      对信号进程做任何处理。
8. 常见 Linux 系统信号的含义及默认操作
   ① SIGHUP: 本信号在用户终端连接（正常或非正常）结束时发出，通常是在终端的控制进程结束时，通知同
   一 session 内的各个作业，这时它们与控制终端不再关联。
   ② SIGINT: 程序终止(interrupt)信号，在用户键入 INTR 字符(通常是 Ctrl + C)时发出。
   ③ SIGQUIT: 和 SIGINT 类似，但由 QUIT 字符控制(通常是 Ctrl + \)来控制。进程在因收到 SIGQUIT 退
   出时会产生 core 文件，在这个意义上类似于一个程序错误信号。
   ④ SIGILL: 执行了非法指令。通常是因为可执行文件本身出现错误，或者试图执行数据段。堆栈溢出时也有
   可能产生这个信号。
   ⑤ SIGTRAP: 由断点指令或其他 trap 指令产生，由 debugger 使用。
   ⑥ SIGKILL: 用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。
   ⑦ SIGALARM: 时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号。
   ⑧ SIGSTOP: 停止进程的执行。注意它和 terminate 以及 interrupt 的区别: 该进程还未执行，只是暂停执
   行。本信号不能被阻塞、处理和忽略。
   ⑨ SIGTSTP: 在用户按下挂起键(一般 Ctrl + Z)时，系统会发送此信号，会造成进程挂起。
   ⑩ SIGTERM: 程序结束(terminate)信号，与 SIGKILL 不同的是该信号可以被阻塞和处理。通常用来要求程序
   自己正常退出。shell 命令 kill 缺省产生这个信号。
9. 信号操作中的常用函数
   函数        功能
   kill        发送信号 SIGKILL 给进程或进程组
   raise       发送信号给进程或自身
   alarm       定时器时间到时，向进程发送 SIGALARM 信号
   pause       没有捕捉信号前一直将进程挂起
   signal      捕捉信号 SIGINT, SIG_IGN, SIG_DFL 或 SIGQUIT 时执行信号处理函数
   sigemptyset 初始化信号集合为空
   sigfillset  初始化信号集合为所有信号集合
   sigaddset   将指定信号加入到指定集合
   sigdelset   将指定信号从信号集中删除
   sigismember 查询指定信号是否在信号集合之中
   sigprocmask 判断检测或更改信号屏蔽字
10.相关系统调用函数
   1）alarm
		unsigned int alarm(unsigned int seconds);
   作用：建立一个进程的报警时钟，当时间（秒计）到达时，就向系统发送一个 SIGALRM 信号。
   说明：
   ① alarm() 不会向 sleep() 那样暂停调用进程的执行，它能立即返回，并使进程继续执行，直至指定的延
   迟时间到达发出 SIGALRM 信号。
   ② 一个由 alarm() 调用设置好的报警时钟，在通过 exec() 调用后，仍将继续有效。但是，它在fork() 调用后中，在子进程中失效。
   ③ 如果要使设置的报警时钟失效，只需要调用参数为零的 alarm(0) 。
   ④ alarm() 调用无法积累。后一次调用会取代前一次调用。但 alarm() 的返回值是前一次设定的报警时钟
   的剩余时间。
   用途：
   先调用 alarm() 按时间限制值设置报警时钟，然后进程作某一工作。如果进程在规定时间内完成这一工作，
   就再调用 alarm(0) 使报警时钟失效。如果在规定时间内未能完成这一工作，进程就会被报警时钟的 SIGALRM 
   信号中断，然后对它进行校正。
   2）pause
		int pause(void);
   作用：使调用进程暂停执行，直至接收某种信号为止。返回始终为-1。
   3）setjmp 和 longjmp
		int setjmp(jmp_buf env);
		void longjmp(jmp_buf env, int val);
   作用：当接收到一个信号时，希望跳回程序中原来的一个位置执行。setjmp() 能保存程序中的当前位置，
   longjmp() 能把控制转回到被保存的位置。setjmp()只有一个参数env，用来保存程序当前位置的堆栈环境。
   longjmp() 有两个参数，分别是 setjmp() 所保存的堆栈环境和其返回值。
   
管道
1. 管道是一种最基本的 IPC 机制，在进程间开辟一个固定大小的缓冲区，需要发布信息的进程运行写操作，需要接
   收信息的进程运行读操作。管道是单向的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。
   管道由 pipe 函数创建。
	#include <unistd.h>
	int pipe(int filedes[2]);
   调用 pipe 函数时在内核中开辟一块缓冲区(称为管道)用于通信，它有一个读端和一个写端，然后通过 filedes 
   参数传出给用户程序两个文件描述符，filedes[0] 指向管道的读端，filedes[1] 指向管道的写端。
   pipe 函数调用成功返回 0, 调用失败返回 -1。
2. 在 Linux 系统中，管道用于两个进程间的通信，这两个进程要有同源性，即它们必须是最终由同一个进程所产生
   的进程。
3. 管道通信采用半双工方式，即同一时间只允许单方向传输数据。
4. 开辟了管道的两个进程间的通信步骤
   (1) 父进程调用 pipe 开辟管道，得到两个文件描述符指向管道的两端
   (2) 父进程调用 fork 创建子进程，那么子进程也有两个文件描述符指向同一管道
   (3) 父进程关闭管道读端，子进程关闭管道写端。父进程写，子进程读，实现进程间通信。
5. 使用管道的 4 种特殊情况
   (1) 如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读
   数据，那么管道中剩余的数据都被读取后，再次 read 会返回 0，就像读取文件末尾一样。
   (2) 如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管
   道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次 read 会阻塞，直到管道
   中有数据可读了才读取数据并返回。
   (3) 如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write
   ，那么该进程会收到信号 SIGPIPE，通常会导致进程异常终止。
   (4) 如果有指向管道读端的文件描述符没关闭（管道读端的引用计数等于0），而持有管道读端的进程也没有从管
   道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次 write 会阻塞，直到管道中有空位置了才
   写入数据并返回。
   
消息队列
1. 消息队列提供了一种由一个进程向另一个进程发送数据块的方法。每一个数据块被看作有一个类型，而接收进程可
   以独立接收具有不同类型的数据块。
2. Linux 系统有两个定义， MSGMAX 与 MSGMNB ，这分别定义单个消息与一个队列的最大尺寸。
3. 几个常用的消息队列函数
	#include <sys/msg.h>
	int msgget(key_t key, int msgflg);
	int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);
	int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);
4. msgget 函数
   (1) 可以使用 msgget 函数创建与访问一个消息队列；key 参数用于指定一个特定消息队列，特殊值 IPC_PRIVATE 
   表示创建一个理论上只可以为当前进程所访问的私有队列。msgflg 参数由九个权限标记组成。
   (2) 要创建一个新的消息队列，由 IPC_CREAT 特殊位必须与其他的权限位进行或操作。如果消息队列已存在，
   IPC_CREAT 被忽略。
   (3) 成功时函数返回一个正数作为队列标识符，失败时返回 -1 。
5. msgsnd 函数
   (1) 允许将消息添加到消息队列。
   (2) 消息结构由两种方式来限定：第一，必须小于系统限制；第二，必须以 long int 开始。
   (3) 当使用消息时，最好是以如下形式来定义消息结构:
		struct my_message {
			long int message_type;     // 用于消息接收
			/** the data you wish to transfer */
		};
   (4) 参数 msqid 是由 msgget 函数所返回的消息队列标识符；参数 msg_ptr 指向要发送消息的指针，这个消息必
   须以 long int 类型开始，如 struct my_message 结构体中定义的 message_type 成员类型；参数 msg_sz 是由
   msg_ptr 所指向的消息的尺寸，这个尺寸必须不包含 long int 消息类型，就如 struct my_message 中 the data
   you wish to transfer 中的长度；参数 msgflg 用于控制如果当前消息队列已满或是达到了队列消息的系统限制
   时如何处理，如果标记设置了 IPC_NOWAIT, 函数就会立即返回而不发送消息，并且返回值为 -1。如果 msgflg 标
   记清除了 IPC_NOWAIT 标记，发送进程就会被挂起，等待队列中有可用的空间。如果成功，函数会返回 0，如果失
   败，则会返回 -1。如果调用成功，系统就会复制一份消息数据并将其放入消息队列中。
6. msgrcv 函数
   (1) 由一个消息队列中收取消息。
   (2) 参数 msqid 是由 msgget 函数所返回的消息队列标识符；参数 msg_ptr 指向要接收消息的指针，这个消息必
   须以 long int 类型开始，如 struct my_message 结构体中定义的 message_type 成员类型；参数 msg_sz 是由
   msg_ptr 所指向的消息的尺寸，这个尺寸必须不包含 long int 消息类型，就如 struct my_message 中 the data
   you wish to transfer 中的长度；参数 msgtype 是一个 long int 类型，允许一个接收优先级形式的实现，如果
   只是简单的希望以其发送的顺序来接收消息，则可以将 msgtype 设置为 0。如果希望接收特殊消息类型的消息，则
   可以将 msgtype 设置为等于这个值。参数 msgflg 用于控制如果当前消息队列没有合适类型的消息正在等待被接收
   时如何处理，如果标记设置了 IPC_NOWAIT, 函数就会立即返回，并且返回值为 -1。如果 msgflg 标记清除了
   IPC_NOWAIT 标记，进程就会被挂起，等待合适类型的消息到来。如果成功，函数会返回放入接收缓冲区中的字节数，
   消息会被拷贝到由 msg_ptr 所指向的用户分配缓冲区中，而数据就会从消息队列中删除，如果失败，则会返回 -1。
	