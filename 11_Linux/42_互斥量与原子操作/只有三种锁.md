
粗糙理解记录，仅供自己参考，可能有误。

编程中常用到的锁一般有三种，分别是自旋锁、互斥锁以及读写锁。三种锁按照顺序由浅到深。

[内核同步方法](https://blog.csdn.net/u012279631/article/details/77677405)

## 自旋锁

自旋锁最多被一个可执行线程持有。一个执行线程尝试持有一个已经被持有的自旋锁时，会一直循环，等待锁重新可用。

自旋并不是独占 CPU，只是把系统当前分配的时间片耗尽。比如系统给某个线程分配了 10 个时间片，已经运行完 6 个，非自旋情况下遇到阻塞剩下的 4 个就不运行了，而自旋的情况下会继续运行完剩下的 4 个。

一个被争用的自旋锁使得请求它的线程在等待锁可重用时自旋，所以实际上自旋锁不应该被长时间持有。自旋锁的目的是在短期内进行轻量级加锁。还可以采取另外的方式来处理对锁的争用，比如让请求线程睡眠，直到锁重新可用时再唤醒线程，这样处理器就不必循环等待，可以去执行其他代码。后者会带来一定的开销——进行两次明显的上下文切换，被阻塞的线程要换出和换入。因此，持有自旋锁的时间最好小于完成两次上下文切换的耗时。

- 预见场景
    + 多核多线程下，存在共享变量 S。
    + a线程访问共享变量S，此时S却被其他线程加锁占有。按理来说a线程应该通知系统执行程序调度，但a线程不想这样做，它觉得自己马上可以等到S，而且这个等待的时间远远小于线程切换的时间。所以a线程就在等待点"死循环一会儿"...
    + 果然，a线程很快等到了其他线程释放锁，于是a对共享变量S加锁占有。
    
- 原理
    + 以 CAS (Compare-And-Swap)为例，示例代码如下:
      ```c++
        template <class T>
        bool CAS(T* addr, T expected, T value)
        {
          if (*addr == expected)
          {
             *addr = value;
             return true;
          }
          return false;
        }
      ```
    + expected 和 value 互否。`*addr=1`, 当加锁时，不妨将 expected=1, value=0。执行加锁运算后 `*addr=0`, 表示资源被占用。然后进入临界区执行运算。解锁时，expected=0,value=1，执行解锁后 `*addr=1`，表示资源被释放。
    + 某个线程进入临界区后，另外的线程如果想要进入临界区，也要执行同样的加锁运算，但因为此时 `*addr=0`, 所以CAS会返回失败，表示加锁失败。如果这时仍旧循环调用CAS，就形成了自旋锁。

- 说明
    + 单核不适合使用自旋锁，虽然抢占式CPU下，线程"死循环等待"不会造成永久卡死，但"死循环"消耗CPU资源，"等待"白白浪费了时间。
    + 自旋锁适合多核下等待时间小于线程切换时间的情况。自旋锁的等待时间可以进行设置，如果这次等待成功，则可以适当延长等待时间；如果等待失败，那么就缩短等待时间。

## 互斥锁
- 预见场景
    + a线程访问共享变量S，此时S却被其他线程加锁占有。这个时间a通知系统执行调度过程，线程进行切换，a被挂起。
    + 可以看出，**互斥锁与自旋锁的区别就是，a线程是否愿意通知系统执行调度。**

- 原理
    + 加锁伪代码实现
      ```c++
        template <class T>
        bool CAS(T* addr, T expected, T value)
        {
          if (*addr == expected)
          {
            保存当前运行线程上下文；
            将线程上下文加入到等待队列；
            设置当前线程状态为等待；
            调度程序；
          }
          return false;
        }
      ```
    + 解锁伪代码实现
      ```c++
        template <class T>
        bool CAS(T* addr, T expected, T value)
        {
          if (*addr == expected)
          {
            将一个线程从等待队列中移出；
            将这个线程加入到就绪队列；
            设置这个线程为就绪状态；
            调度程序；
          }
          return false;
        }
      ```
+ 说明
    + 互斥锁既适用于单核CPU，也适用于多核CPU。
    + 生产者-消费者模型是互斥锁的典型应用场景。
+ 使用信号量来实现互斥锁
    + 基本思想是将每个共享变量(或者一组相关的共享变量)与一个信号量s(初始为1)联系起来，然后用P(s)和V(s)操作将相应的临界区包围起来。
    + 以这种方式来保护共享变量的信号量叫做二元信号量，因为它的值总是0或1。以提供互斥目的的二元信号量常常也称为互斥锁。在一个互斥锁上执行P操作称为对互斥锁加锁，执行V操作称为对互斥锁解锁。
    + 保护一个共享变量伪代码实现
      ```c
        volatile int cnt = 0;
        sem_t mutex;
        
        sem_init(&mutex, 0, 1);
        
        P(&mutex);
        cnt++;
        V(&mutex);
      ```
    + 保护一组相关的共享变量(生产者-消费者模型)伪代码实现
      ```c
        sem_t mutex, slots, items;
        
        sem_init(&mutex, 0, 1);
        sem_init(&slots, 0, n); // 开始时可用缓冲区为 n
        sem_init(&items, 0, 0); // 开始时无可处理元素
        
        // 生产者线程
        P(&slots);
        P(&mutex);
        向缓冲区添加元素
        V(&mutex);
        V(&items);
        
        // 消费者线程
        P(&items);
        P(&mutex);
        从缓冲区移出元素
        V(&mutex);
        V(&slots);
      ```

## 读写锁
- 预见场景
    + a要访问共享变量S，但是之前已经有其他线程加锁过了并设置了一些条件，如果其他线程满足这些条件，那么就可以直接进入临界区。
    + a比对了一下这些条件，发现满足，于是a就进行了临界区。
    + 可以看出，**读写锁就是加了一些限制条件的互斥锁。**
    + 这就是读者-写者场景。而读写锁通常也是用于这种读多于写的场景。
    + 读者-写者又分为读者优先和写者优先两种，读者优先时常常会因为写者等不到锁而饿死，所以一般应用场景多为写者优先，比如 POSIX 的读写锁。
    + 在读者优先的基础上再加入一些限制条件，可以实现写者优先。
- 原理
    + 读写锁-读者优先伪代码实现
      ```c
        int readcnt = 0;
        sem_t mutex, w;     // 均初始化为 1
        
        // 读者线程
        P(&mutex);
        readcnt++;
        if (readcnt == 1) { // 第一个读者进来了，其他的读者可以不用等待加锁而直接进入
            P(&w);
        }
        V(&mutex);
        // 临界区
        P(&mutex);
        readcnt--;
        if (readcnt == 0) {
            V(&w);          // 最后一个离开的读者释放锁
        }
        V(&mutex);
        
        // 写者线程
        P(&w)
        // 临界区
        V(&w);
      ```
    + 读写锁-写者优先伪代码实现
      ```c
        int readcnt = 0;
        sem_t mutex, w, noti;   // 均初始化为 1
        bool wf = false;        // 写者是否要求写的标志
        
        // 读者线程
        if (wf == true) {       // 写者线程正在等待
            P(&noti);           // 等待加锁，而后立马释放锁
            V(&noti);
        }
        
        P(&mutex);
        readcnt++;
        if (readcnt == 1) {
            P(&w);
        }
        V(&mutex);
        // 临界区
        P(&mutex);
        readcnt--;
        if (readcnt == 0) {
            V(&w);              // 最后一个离开的读者释放锁
        }
        V(&mutex);
        
        // 写者线程
        P(&noti);
        wf = true
        P(&w)
        // 临界区
        V(&w);
        V(&noti);
        wf = false;
      ```
- [Linux POSIX 读写锁函数](读写锁函数.md)
    
## 哲学家吃饭
- 问题: 五个哲学家围在一个圆桌上，哲学家与哲学家之间都有一根筷子，每个哲学家获得了两根筷子才能吃饭。
- 解决办法一:
    + 五个哲学家均先尝试拿起自己左手边的筷子，再尝试拿起自己右手边的筷子
      ```c
        sem_t s;    // 初始化为 5

        // 哲学家线程
        P(&s[左边]);
        P(&s[右边]);
        吃饭
        V(&s[右边]);
        V(&s[左边]);
      ```
    + 会出现一个极端问题，五个哲学家均同时拿起自己左手边的筷子，再等待右手边的筷子空闲下来。这个时候会造成死锁。
- 解决办法二:
    + 加入互斥锁，保护一个哲学家拿起左边的筷子，再拿起右边的筷子
      ```c
        sem_t s;        // 初始化为 5
        sem_t mutex;    // 初始化为 1
        
        
        // 哲学家线程
        P(&mutex);
        P(&s[左边]);
        P(&s[右边]);
        吃饭
        V(&s[右边]);
        V(&s[左边]);
        V(&mutex);
      ```
    + 也有一个问题，那就是一次只能有一个人吃饭，但事实上最多可允许两个人同时吃饭。
- 解决办法三:
    + 奇数座位的哲学家先尝试拿起左边的筷子，再尝试拿起右边的筷子；偶数座位相反操作。
      ```c
        sem_t s;        // 初始化为 5
        
        // 哲学家线程
        if (奇) {
            P(&s[左边]);
            P(&s[右边])
        } else {
            P(&s[右边]);
            P(&s[左边]);
        }
        吃饭
        V(&s[左边]);
        V(&s[右边]);
      ```
    + 可以两个人同时吃饭了，算是解决了这个问题。
