
read() 和 write() 系统调用在操作磁盘文件时不会直接发起磁盘访问，而是仅仅在用户空间缓冲区与内核缓冲区调整缓存(kernel buffer cache)之间复制数据。例如，如下调用将 3 个字节的数据从用户空间内存传递到内核空间的缓冲区中:
```c
    write(fd, "abc", 3);
```
write() 随即返回。在后续的某个时刻，内核会将其缓冲区中的数据写入磁盘。因此，可以说系统调用与磁盘操作并不同步。如果在此期间，另一进程试图读取该文件的这几个字节，那么内核将自动从缓冲区高速缓存中提供这些数据，而不是从文件中(读取过期的内容)。

与此同理，对输入而言，内核从磁盘中读取数据并存储到内核缓冲区中。read() 调用将从该缓冲区中读取数据，直至把缓冲区中的数据读完，这时，内核会将文件的下一段内容读入缓冲区高速缓存。(对于顺序IO，内核通常会尝试执行预读。)

采用这一设计，read() 和 write() 调用的操作更为迅速，因为它们不需要等待(缓慢的)磁盘操作。同时也减少了内核必须执行的磁盘传输次数。

Linux 内核对缓冲区高速缓存的大小没有固定上限。内核会分配尽可能多的缓冲区高速缓存页，而仅受限于两个因素: 可用的物理内存总量，以及出于其他目的的对物理内存的需求。

> 缓冲区大小对 I/O 系统调用性能的影响: 如果与文件发生大量的数据传输，通过采用大块空间缓冲数据，可以降低系统调用的次数，从而极大地提高 I/O 性能。

### stdio 的缓冲

C 语言函数库的 I/O 函数(比如 fprintf()、fscanf()、fgets()、fputs()、fputc()、fgetc()) 正是这么做的。使用 stdio 库可以使编程者免于自行处理对数据的缓冲。

`setvbuf()` 可以控制 stdio 库使用缓冲的形式。
```c
    #include <stdio.h>

    int setvbuf(FILE *stream, char *buf, int mode, size_t size);
```
- 参数:
    - buf 和 size： 针对 stream 要使用的缓冲区，指定这些参数有如下两种方式:
        - 如果 buf 不为 NULL, 那么其指向 size 大小的内存块以作为 stream 缓冲区。
        - 如果 buf 为 NULL, 那么 stdio 库会为 stream 自动分配一个缓冲区，size 会被忽略。
    - mode 指定了缓冲类型，可取值如下:
        - _IONBF: 不对 I/O 进行缓冲，并且忽略 buf 和 size 参数，可以分别指定两个参数为 NULL 和 0 。stderr 默认属于这一类型，从而保证错误能立即输出。
        - _IOLBF: 采用行缓冲 I/O。指代终端设备的流默认属于这一类型。对于输出流，在输出一个换行符(除非缓冲区已经填满)前将缓冲数据。对于输入流，每次读取一行数据。
        - _IOFBF: 采用全缓冲 I/O。单次读、写数据在大小与缓冲区相同。指代磁盘的流默认采用此模式。

> 逐行扫描文本文件时，将缓冲类型设置为行缓冲，避免了对换行符的判断，可以有效提高文件处理速度。


无论当前采用何种缓冲区模式，在任何时候，都可以使用 `fflush()` 库函数强制将 stdio 输出流中的数据(即通过 write()) 刷新到内核缓冲区中。
```c
    #include <stdio.h>

    int fflush(FILE *stream);
```
- 也能将该函数应用于输入流，这将丢弃业已缓冲的输入数据。
- 若参数 steam 为 NULL, 则将刷新所有的 stdio 缓冲区。

### 控制文件 I/O 的内核缓冲

强制刷新内核缓冲区到输出文件是可能的。有时很有必要。

同步 I/O 的完整性的定义分为两种: 一种是数据完整性，另一种是在第一种的基础上再加上元数据的文件完整性(如写入数据时会涉及到对文件大小、修改时间等的更新)。

第一种同步 I/O 完成类型是 `synchronized I/O data integrity completion`:
- 就读操作而言，这意味着被请求的文件数据已经(从磁盘)传递给进程。
- 就写操作而言，这意味着写请求所指定的数据已传递(至磁盘)完毕，且用于获取数据的所有文件元数据也已传递(至磁盘)完毕。

`synchronized I/O data integrity completion` 是上述完成类型的超集，它与上面的区别在于在对文件的一次更新过程中，要将所有发生更新的文件元数据都传递到磁盘上，即使有些在后续对文件数据的读操作中并不需要。

`fsync()` 系统调用将使缓冲数据和与打开文件描述符 fd 相关的所有元数据都刷新到磁盘上，即完成第二种同步。
```c
    #include <unistd.h>

    int fsync(int fd);
```
仅在对磁盘设备(或者至少其高速缓存)的传递完成后，函数调用才会返回。成功时返回 0，失败时返回 -1 。

`fdatasync()` 系统调用的运作类似于 fsync()，只是强制完成第一种同步。
```c
    #include <unistd.h>

    int fdatasync(int fd);
```
成功时返回 0，失败时返回 -1 。可适用在对性能要求极高，而对某些元数据(比如时间戳)的准确性要求不高的应用。

`sync()` 系统调用会使包含更新文件信息的所有内核缓冲区(即数据块、指针块、元数据等)刷新到磁盘上。
```c
    #include <unistd.h>

    int sync(void);
```

调用 open() 函数时如指定 O_SYNC 标志，则会使所有后续输出同步。
```c
    fd = open(pathname, O_WRONLY | O_SYNC);
```
调用 open() 后，每个 write() 调用会自动将文件数据和元数据刷新到磁盘上，即实现第二种状态。

可以预想地是，打开描述符时设置 O_SYNC 位或者频繁地调用文件同步函数将对性能有所影响。

### I/O 缓冲小结

首先通过 stdio 库将用户数据传递到 stdio 缓冲区，该缓冲区位于用户态内存区。当缓冲区填满时，stdio 库会调用 write() 系统调用，将数据传递到内核高速缓冲区(位于内核态内存区)。最终，内核发起磁盘操作，将数据传递到磁盘。
