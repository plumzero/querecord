


### 进程与内核

内核的职责之一就是创建和终止进程。

内核在执行进程时，会将程序代码载入虚拟内存，为程序变量分配空间，为每一个进程都分配了一个 `tast_struct` 的内核记账数据结构(以记录与进程有关的各种信息，比如进程ID、用户ID、组ID以及终止状态等)，有时也称之为进程控制块(PCB)。

系统利用 PCB 来控制和管理进程，所以 PCB 是系统感知进程存在的唯一标志，是接受内核调度的基本单位，记录着进程所占用的各项资源。进程与 PCB 是一一对应的关系。

tast_struct 结构体中比较重要的成员介绍:
- state: 进程当前的运行状态
  - TASK_RUNNING: 可执行状态（或就绪状态）
  - TASK_INTERRUPTIBLE: 可中断的睡眠状态，可因某个信号的到来而被唤醒
  - TASK_UNINTERRUPTIBLE: 不可中断的睡眠状态，不会因信号或软中断而被唤醒
  - TASK_STOPPED: 挂起状态，主要用于调试。接收到 SIGSTOP 信号进入此状态，直到接收到 SIGCONT 信号才恢复到可执行状态
  - TASK_ZOMBIE: 僵尸状态，进程已死但其所占资源尚未回收
  - TASK_DEAD: 进程彻底结束
- policy: 适用于本进程的调试策略，用以区分两种进程: 实时进程和普通进程
- pid: 进程标识符，也称进程号，唯一
- rt_priority: 进程实时优先级，通常由用户指定和系统设置
- 实际用户标识符 uid 和组标识符 gid:	用来标识进程属于哪个用户和用户组
- 有效用户标识符 euid 和有效组标识符 egid: 用来决定对文件的访问权限
- user指针: 代表着进程所属的用户

Linux 系统下，可以通过 ps 命令命令查看进程的状态，如 `ps -aux` 会以 BSD 风格展示进程的状态:
```s
  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
  root         1  0.0  0.0 185420  6052 ?        Ss   09:43   0:01 /sbin/init splash
  root         2  0.0  0.0      0     0 ?        S    09:43   0:00 [kthreadd]
  root         4  0.0  0.0      0     0 ?        I<   09:43   0:00 [kworker/0:0H]
  root         6  0.0  0.0      0     0 ?        I<   09:43   0:00 [mm_percpu_wq]
  root         7  0.0  0.0      0     0 ?        S    09:43   0:00 [ksoftirqd/0]
```
上面每行的信息依次表示: 进程所有者、进程ID、CPU占用、进程虚拟大小、页面文件占用、终端ID、进程状态、进程开始运行时间等。

每个进程都有一个`当前工作目录`(有时简称为进程工作目录或当前目录)。可使用 cd 命令来改变 shell 的当前工作目录。

### 创建进程和执行程序

创建进程，事实上是复制进程。内核通过对父进程的复制来创建子进程。子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进程的"原版"内容。(在内存中标记为只读的程序文件段则由父、子进程共享)

Linux系统中，新进程的产生分为两步，第一步是从父进程中复制出一个子进程，此子进程有自己的 task_struct 结构和系统空间堆栈，但与父进程共享其他所有资源。假如父进程打开了5个文件，则子进程也有打开这5个文件，且文件当前读/写指针也停留在相同地方。

每一进程都有一个唯一的整数型进程标识符(PID)。此外，每一进程还具有一个父进程标识符(PPID)属性，用以标识请求内核创建自己的进程。
```c
  pid_t getpid(void);		// 返回系统当前进程的进程ID
```

Linux提供了两个系统调用进行进程复制: `fork()` 函数和 `clone()` 函数。区别如下:
- fork(): 最基本资源全部复制，如 tast_struct 块、系统空间堆栈、页面表等，对父进程代码及全局变量则不需要复制，仅通过只读访问形式实现共享。
- clone(): 选择性复制，没有复制的数据结构通过指针共享给子进程

```c
  pid_t fork(void);
```
- 被调用一次，但返回两次。子进程先返回，之后将子进程ID返回给父进程。子进程返回0，父进程返回新的子进程的ID。
- fork返回后，子进程和父进程都从调用 fork 函数的下一条语句开始执行。但哪个进程先执行不确定，可通过进程间通信实现进程间的相互同步。
- fork出错两种可能原因:
	- 当前进程数已经达到了系统规定的上限，这时 errno 值被设置为 EAGAIN(如果出错，最有可能是这种)
	- 系统内存不足，这时 errno 值被设置为 ENOMEM
- 由 fork 创建的父子进程并不是数据共享的，是相互独立的。

- [简单的fork示例](t/fork_simgle.cc)
- [通过单例了解进程的fork](t/fork_singleton.cc)

系统调用 `vfork()` 也可进行复制，但实质创建出来的是线程而不是进程，因为它缺少进程所必要的独立的内存空间。
```c
  pid_t vfork(void);	// 返回值同fork
```
- 返回后，子进程先执行，父进程挂起，直到子进程调用 exec 或 exit 后，父子进程的执行次序才不再有限制。
- 由 vfork 创建出来的子进程与父进程是共享内存区的。

子进程在创建之后，要么去执行与父进程共享代码段中的另一组不同函数，或者，更为常见的情况是使用系统调用 `execve()` 去加载并执行一个全新程序。 execve() 会销毁现有的文本段、数据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们。


clone() 是 Linux 系统特有的系统调用，在 Linux 系统中， fork 和 pthread 都是基于 clone 实现的。形式如下:
```c
	int clone(int(*fn)(void * arg), void *stack, int flag, void *arg);
```
- 参数 fn 是轻进程所执行的函数；stack 是轻进程所使用的栈，flag 是 CLONE_VM、CLONE_FS、CLONE_FILES、CLONE_SIGHAND、CLONE_PID 的组合，arg 是调用过程的对应参数。
- clone() 的关键是 flag 的设定，其中 CLONE_VM 表示子进程共享父进程的文件系统，CLONE_SIGHAND 表示子进程共享父进程的消息处理机制，CLONE_PID 是指子进程继承父进程的 id 号。

- [exec函数族说明](exec函数族.md)
- [system函数说明](system函数.md)

### 进程终止和终止状态

可以使用以下两种方式之一来终止一个进程:
- 进程可使用 _exit() 系统调用(或相关的 exit() 库函数)，请求退出
- 向进程传递信号，将其"杀死"
```c
	void exit(int status);	//参数为0表示正常结束，否则表示出现错误
	void _exit(int status);	//同上
```
两者的区别是 exit() 函数在调用之前要检查文件的打开情况，把文件缓冲区内容写回文件，_exit() 函数直接停止进程，清除其使用的内存空间，不对标准I/O作任何操作。

无论以何种方式退出，进程都会生成"终止状态"，一个非负小整数，可供父进程的 `wait()` 系统调用检测。

在调用 _exit() 的情况下，进程会指明自己的终止状态。若由信号来"杀死"进程，则会根据导致进程"死亡"的信号类型来设置进程的终止状态。(有时会将传递进 _exit() 的参数称为进程的"退出状态"，以示与终止状态有所不同，后者要么指传递给 _exit() 的参数值，要么表示"杀死"进程的信号。)

根据惯例，终止状态为 0 表示进程"功成身退"，非 0 则表示有错误发生。大多数 shell 会将前一执行程序的终止状态保存于 shell 变量 `$?` 中。

子进程尚未终止时，父进程却终止了。一般允许父进程结束，并把它的子进程交归系统的初始化进程。

### 进程等待

有时父进程需要停下来，也就是进入睡眠状态，等待子进程执行完成并结束，然后父进程再继续执行。如果父进程因执行了 wait() 调用而处于睡眠状态，那么子进程执行 exit() 会重新启动父进程运行。

在一个进程调用了 exit 之后，该进程并非立即消失，而是留下一个称为僵尸进程的数据结构。这时的处理方法之一就是使用进程等待的系统调用 `wait` 和 `waitpid`。

> 僵尸进程是指已终止运行，但尚未被清除的进程。当使用 fork() 函数创建子进程时，由于子进程有可能比父进程晚终止，当父进程终止后，子进程还没终止，子进程就成为了僵尸进程。
> 僵尸进程是一个运行完毕的进程，所有资源都已经释放了，除了它的进程表项。
> 为了避免僵尸进程，父进程通过 wait 和 waitpid 等函数等待子进程结束，这会导致父进程挂起。

僵尸进程没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集。
```c
	pid_d wait(int *status);
```
- 参数 status 用来保存被收集(等待)进程退出时的状态。若成功，返回被等待进程ID，否则返回 -1，同时 errno 被置为 `ECHILD`。
- 进程一旦调用了 wait，就立即阻塞自己，由 wait 自动分析是否当前进程的某个子进程已经退出，如果让它找到这样一个已经变成僵尸的子进程，wait 就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait 会一直阻塞在这里，直到有一个出现为止。
- 参数 status 用来保存被收集进程退出时的一些状态。如果对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，就可以设定这个参数为 NULL。

```c
  pid_t waitpid(pid_t pid, int *status, int options);
```
与 wait 不同，waitpid 可以通过设置一个选项来设置为非阻塞，另外 waitpid 并不是等待第一个结束的进程，而是等待参数中 pid 指定的进程。

- 参数一可取值及含义：
  - pid > 0		只等待进程ID为 pid 的子进程，不管其他已经有多少子进程退出，只要指定的子进程没有结束，就一直等待下去
  - pid = -1	等待任何一个子进程退出
  - pid = 0		等待同一个进程组中的任何子进程，如果某一子进程已经加入了别的进程组，waitpid 忽略其
  - pid < -1	等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值
- 参数二取值选项
  - `#define WNOHANG 	0x00000001`		// 即使没有子进程退出，也会立即返回，不会等待下去
  - `#define WUNTRACED	0x00000002`

[fork并等待示例](t/fork_waitpid.cc)

`ret = waitpid(-1, NULL, 0);`等同于调用 wait 。

```c	
	pid_t wait3(int *status, int options, struct rusage * rusage);
	pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);
```
- wait3 和 wait4 分别相当于 wait 和 waitpid，其在 waitpid 的基础上增加了可以获取进程及其子进程所占resources的情况的功能。
- 如果 rusage 不为 NULL，则关于子进程执行时的相关信息将被写入该指针指向的缓冲区。

### init 进程

系统引导进，内核会创建一个名为 init 的特殊进程，即"所有进程之父"，该进程的相应程序文件为 /sbin/init。

系统的所有进程不是由 init(使用 fork())"亲自"创建，就是由其后代进程创建。init 进程的进程号总为 1， 且总以超级用户权限运行。谁(哪怕是超级用户)都不能"杀死" init 进程，只有关闭系统才能终止该进程。

root 权限和 init 进程的区别: 前者一般是具有 root 权限的用户(用户 id 为 0)，后者是一个进程。
  
### 进程环境列表

- 每个进程都有一个环境列表，即在进程用户空间内存中维护的一组环境变量。
- 由 fork() 创建的新进程，会继承父进程的环境副本。这也为子父子进程间通信提供了一种机制。
- 可以通过 exec() 族函数指定新环境并加以接收。
  
### 进程资源限制

- 每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用 `setrlimit()`，进程可为自己消耗的各类资源设定一个上限。
- 此类资源限制的每一项均有两个相关值: 软限制(soft limit)限制了进程可以消耗的资源总量，硬限制(hard limit)是软限制的调整上限。
- 非特权进程在针对特定资源调整软限制值时，可将其设置为 0 到相应硬限制值之间的任意值，但硬限制值只能调低，不能调高。
- 由 fork() 创建的新进程，会继承其父进程对资源限制的设置。
- 使用 ulimit 命令可调整 shell 的资源限制。shell 为执行命令所创建的子进程会继承上述资源限制。

### 进程优先级

系统以整型变量 nice 来决定一个特定进程可得到的 CPU 时间的比例。Nice的值从零至其最大值。进程的优先数越大，其优先权就越低。普通进程可以使用系统调用`nice()`来降低它的优先权，以把更多的资源分给其他进程。

### 进程内存状态量

- VmSize: 虚拟内存大小。整个进程使用虚拟内存大小，是VmLib, VmExe, VmData, 和 VmStk的总和。
- VmLck: 虚拟内存锁。进程当前使用的并且加锁的虚拟内存总数。
- VmRSS: 虚拟内存驻留集合大小。这是驻留在物理内存的一部分。它没有交换到硬盘。它包括代码，数据和栈。
- VmData: 虚拟内存数据。堆使用的虚拟内存。
- VmStk: 虚拟内存栈。栈使用的虚拟内存。
- VmExe: 可执行的虚拟内存。可执行的和静态链接库所使用的虚拟内存。
- VmLib: 虚拟内存库。动态链接库所使用的虚拟内存。

### 会话、控制终端和控制进程

一个或多个进程合起来构成一个`进程组`，一个或多个进程组合起来构成一个`会话`。如此可对进程进行批量操作，如通过向某进程组发送信号来实现向组内所有进程发送信号。

会话中的所有进程都具有相同的会话标识符(会话 ID)。会话首进程(session leader)是指创建会话的进程，其进程 ID 会成为会话 ID。

会话都会与某个控制终端相关，使用会话最多的是支持任务控制的 shell 。通过远程终端工具(如 putty, SecureCRT)打开一个终端 ，即创建一个 shell 会话，shell 也是此会话的会话首进程。通过此 shell 创建的所有进程组与 shell 自身隶属于同一会话。打开控制终端会致使会话首进程成为终端的控制进程。一旦断开了与终端的连接(比如关闭了终端窗口)，控制进程将会收到 `SIGHUP` 信号。经过测试，关闭控制终端时，会话中进程组中的进程均会收到 SIGHUP 信号。

进程最初是通过 fork() 和 exec 调用来继承其进程组标识符。但是，进程可以使用系统调用`setpgrp()`，自己形成一个新的组。setpgrp() 的返回值 newpg 是新的进程组标识符，即调用进程的进程标识符。它所建立的所有进程，将继承 newpg 中的进程组标识符。一个进程可以用系统调用 `getpgrp()` 来获得其当前进程标识符。

### 与进程管理相关的其他系统调用

改变当前工作目录。参数是要转去的路径。
```c
	int chdir(const char *path);
```

调用后，调用进程会成立一个新的会话，并自任该会话的组长。
```c
	pid_t setsid(void);
```

设定一个文件权限掩码，用户可以用它来屏蔽某些权限。
```c
	mode_t umask(mode_t mask);
```
