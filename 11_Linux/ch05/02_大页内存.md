
本示例测试是在 Intel 架构上进行的。

CPU 是否支持大页内存，可以通过 CPU flags 进行判断:
- 如果 `pse` 存在，则支持 2M 大页
- 如果 `pdpe1gb` 存在，则支持 1G 大页


### 设置大页数量

```sh
    echo 16 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
```

查看大页信息:
```sh
    grep -i huge /proc/meminfo
```
执行上面的命令，有如下输出:
```sh
    AnonHugePages:         0 kB
    HugePages_Total:      16
    HugePages_Free:       16
    HugePages_Rsvd:        0
    HugePages_Surp:        0
    Hugepagesize:       2048 kB
```
表示尺寸为 2M 的大页数量一共有 16 个，其中可用的有 16 个。

### 挂载大页

预留大页之后，为了让大页可用，需要挂载大页:
```sh
    mkdir /mnt/huge
    mount -t hugetlbfs nodev /mnt/huge
```

如果想要永久挂载大页(即开机可用)，可以将如下语句添加到 `/etc/fstab` 文件中:
```sh
    nodev /mnt/huge hugetlbfs defaults 0 0
```
对于 1GB 大页，则是如下语句:
```sh
    nodev /mnt/huge_1GB hugetlbfs pagesize=1GB 0 0
```

### 对大页的测试与使用

以下测试包括了笔者能使用到的常用场景，可作参考:
- [大页+匿名映射](t/02_hp_anon.cpp)
- [大页+非匿名映射](t/02_hp_fd.cpp)
- [大页+共享内存+匿名映射](t/02_hp_shared_anon.cpp)
- [大页+共享内存+非匿名映射](t/02_hp_shared_fd.cpp)

`大页 + 共享内存 + /dev/zero` 的使用还有些奇怪，这是[示例代码](t/02_hp_zero.cpp)。

使用大页与不使用大页的效率测试。

