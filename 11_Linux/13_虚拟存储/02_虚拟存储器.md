
### 概念

虚拟存储器是对内存和IO设备(包括硬盘)的抽象，处理器通过虚拟地址来访问内存，这个虚拟地址在被送到内存之前，会先转换成适当的物理地址。

虚拟存储器使得进程好像拥有了比整个内存容量大得多的内存空间。此外，这种设计也简化了操作系统和编译器的设计，比如可以假设进程的可执行代码的起始地址都是 0x00400000，而具体的物理地址是多少则由映射机制解决，那么操作系统只需要从地址 0x00400000 处加载程序代码，而不必关心代码保存在哪个位置。

虚拟存储器使用虚拟地址寻址，而物理存储器使用物理地址寻址，因此硬件执行访存操作时需要将虚拟地址翻译成物理地址，操作系统和存储器管理单元(Memory Management Unit, MMU)硬件配合来完成这一工作。


## 物理寻址
- 计算机系统的主存被组织成一个由连续字节单元组成的数组，每个字节都有一个唯一的物理地址。
- CPU 加载某条指令时，它会生成一个有效的物理地址，通过存储器总线，把它传递给主存。主存根据这个物理地址取出相应字节，并将它返回给CPU，后者将它存放在一个寄存器里。
- 早期计算机使用物理寻址。

## 虚拟寻址
- CPU 通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址(称为地址翻译)。
- CPU 通过存储器管理单元来执行地址翻译。

## 虚拟地址空间与物理地址空间
- 通过地址总线位宽n(一般是32位或64位)来创建一个虚拟的线性地址空间，其大小为 2^n，范围为 0~2^n-1 。
- 真实物理存储器的线性地址空间，比如能够存储 M 个字节，那么它的范围就是 0~M 。

## 虚拟存储器(VM)中的缓存命中执行过程
- VM 将虚拟存储器分割为虚拟页，虚拟页往往很大，一般为4KB~2MB。类似地，物理存储器被分割为物理页。
- 在任意时刻，虚拟页的集合分为三个不相交子集，分别是: 
    + 未分配的: 没有任何数据与其关联，不占用任何磁盘空间。
    + 缓存的: 当前缓存在物理存储器的的已分配页。
    + 未缓存的: 没有缓存在物理存储器的已分配页。
- 虚拟存储器以某种办法判定一个虚拟页是否存放在虚拟存储器缓存中。如果存在缓存中，系统还必须确定这个虚拟页存放在哪个物理地址中。如果(虚拟存储器缓存)不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到虚拟存储器缓存中，替换这个牺牲页。

## 页表、页命中和缺页
- 页表: **页表**将虚拟页映射为物理页，每次地址翻译硬件将一个虚拟地址转换为物理地址时都会读取页表。
- 通过页表成功通过虚拟地址找到物理地址，称为页命中。
- 虚拟页是未没有缓存在物理存储器上的已分配页，造成虚拟存储器缓存不命中，称为缺页。发生缺页异常时会调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，内核将这个牺牲页拷贝回磁盘，并更改对应页表为未缓存。接着，内核从磁盘拷贝需要的页到物理存储器，更新页表，随后返回。

## 页面调度与局部性
- 磁盘与存储器之间传送页的活动叫做交换与页面调度。页从磁盘换入存储器和从存储器换出磁盘。
- 当有不命中发生时，会产生页面换入。大量的页面换入会使程序颠簸，破坏程序性能。不过实际上，虚拟存储器工作的相当好，这主要归功于**局部性**。
- 尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序将往往在一个较小的活动页面集合上工作。所以只要程序有好的时间局部性，虚拟存储器系统就能工作得相当好。

## 虚拟存储器作为存储器管理的工具
- 操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。不同进程中的虚拟页可以映射到同一个共享物理页上。按需页面调度和独立的虚拟地址空间的结合，对于存储器的使用和管理而言，可以:
    + 简化链接: 独立的地址空间允许每个进程的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。
    + 简化加载: 同样，因为具有相同的基本格式，也很容易向存储器加载可执行文件和共享对象文件。
    + 简化共享: 一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况下，操作系统创建页表，**将相应的虚拟页映射到不同的物理页面**。然而，一些情况下，需要进程共享代码和数据，如库函数调用或磁盘文件。这个时候，操作系统通过将不同进程中适当的虚拟业映射到相同的物理页，从而安排多个进程共享这部分代码的一个拷贝。
    + 简化存储器分配：当一个运行在用户进程中的程序要求额外的堆空间(malloc)时，操作系统会分配适当多个连续虚拟存储器页面，并将它们映射到任意位置的不同物理页面中。
      这个也是堆中分配内存比栈中效率要低的一个原因，因为对堆内存的读写会发生成在不同的物理页中，而对栈的读写一般是在一个物理页中完成。
    
## 段错误是怎么来的
- 通过对页表添加一些额外的许可位来控制对某个虚拟页面的访问。
- 一般有三个许可位: SUP - 超级用户才能访问；READ - 只读页面；WRITE - 可写页面。
- 如果一条指令违反了上述许可条件的一个，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序，这种异常报告被称为"段错误"。

## Linux 缺页异常处理
- Linux 并不会对每种缺页异常进行处理。如果在翻译虚拟地址A时触发了一个缺页，这个异常导致控制转移到内核的缺页处理程序，然后执行如下步骤:
    
    1. 虚拟地址A是否合法。如果不合法，那么缺页处理程序就触发一个段错误，从而终止这个进程。
    2. 操作是否合法。即进程是否有读、写或者执行这个区域内页面的权限？如果访问不合法，也会触发保护异常。
    3. 前两步没有问题之后，内核知道这是对合法虚拟地址的合法操作，于是执行相应的换页操作。
    
## 存储器映射
- 定义
    + Linux 通过将一个虚拟存储器区域与一个磁盘上的对象关联起来,以初始化这个虚拟存储器区域的内容,这个过程称为存储器映射。
    + 存储器映射有两种，这里只记录 Unix 文件系统中的普通文件映射。
- Unix 文件系统中的普通文件映射
    + 文件被分成页大小的片。因为页面按需调度，所以**这些虚拟页面没有实际交换进入物理存储器，直到CPU第一次引用到页面。**
- 共享对象
    + 一个对象被映射到虚拟存储器的一个区域，要么作为共享对象，要么作为私有对象。
    + 如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟存储器的其他进程而言也是可见的。而且，**这些变化也会反映在磁盘上的原始对象中。**
    + 另一方面，对一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且**进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。**
- 私有对象与写时拷贝(copy-on-write)
    + 私有对象通过写时拷贝来充分利用物理内存。
    + 进程a映射到物理页中，作为自己的私有对象。进程b映射的内容与a相同，此时也映射到同一个物理页中，作为自己的私有对象。
    + 对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为**私有的写时拷贝**。
    + 如果某个进程试图写它自己的私有区域内的某个页面，那么这个写操作就会触发一个保护故障。此时故障处理程序会为写进程创建这个页面的一个新拷贝，更新页表条目指向这个新的拷贝，然后恢复这个页面的可写权限。

## fork 函数
- 当 fork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟存储器，它创建了当前进程的 mm_struct、区域结构和页表的原样。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时拷贝。
- 当 fork 在新进程中返回时，新进程现在的虚拟存储器刚好和调用 fork 时存在的虚拟存储器相同。当这两个进程中的任一个后来进行写操作时，写时拷贝机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。

## execue 函数
- 删除进程原有虚拟存储器。
- 为新进程创建新的虚拟存储器（私有，写时拷贝）。

## mmap 函数
- Linux/Unix 进程可以使用 mmap 函数来创建用户级的虚拟存储器区域，并将对象映射到这些区域中。
  ```c
    #include <unistd.h>
    #include <sys/mman.h>
    
    void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
  ```
  创建一个新的虚拟存储器区域，该区域地址从 start 开始，并将文件描述符 fd 指定的对象的一个连续的片(chunk)映射到这个新的区域。
- 参数说明
    + start: 一般传入 NULL。
    + length: 连续的对象片大小
    + offset: 从距文件开始处偏移量为 offset 字节的地方开始映射。
    + fd: 文件对象的描述符
    + prot: 对新映射的虚拟存储器区域的权限访问位。
        + PROT_EXEC: 可执行
        + PROT_READ: 可读
        + PROT_WRITE: 可写
        + PROT_NONE: 不能被访问
    + flags: 被映射对象类型。
        + MAP_ANON: 匿名对象
        + MAP_PRIVATE: 私有、写时拷贝对象
        + MAP_SHARED: 共享对象
- 使用示例
  ```c
    新区域地址 = mmap(-1, size, PROT_READ, MAP_PRIVATE|MAP_ANON, 0, 0);
  ```
- munmap 函数，删除虚拟存储器的区域
  ```c
    #include <unistd.h>
    #include <sys/mman.h>
    
    int munmap(void* start, size_t length);
  ```

## 动态存储器分配
- 略


## Linux 下的进程与线程
- linux 下的线程实质上还是进程。
- linux 下无论是进程还是线程，都是用 task_struct 结构表示的，唯一的区别就是共享的数据区域不同。
  ```c
    struct task_struct {
        long state;             // 进程状态
        struct mm_struct * mm;  // 虚拟存储区
        pid_t pid;              // 进程号
        struct task_struct __rcu * parent;  // 指向父进程的指针
        struct list_head children;  // 子进程列表
        struct fs_struct * fs;  // 存放文件系统信息的指针
        struct files_struct * files;    // 一个数组，包含该进程打开的文件指针
    };
  ```
  其中 mm 指向的是进程的虚拟存储区，也就是载入资源和可执行文件的地方。files 指向一个数组，里面装着所有该进程打开的文件的指针。
- Linux 下进程通过 fork() 创建，线程通过 pthread_create() 创建，进程和线程的区别主要在于 mm 区域和 files 区域是否共享。
- 关于mm: 父进程创建子进程后，父子进程的虚拟页映射到相同的物理页。在某个进程需要写时，通过写时拷贝会在物理存储器上创建一个原物理页的拷贝给操作进程，这样任何一个进程对虚拟存储区的读写就不会影响到其他进程。主线程创建一个对等线程时，二者虚拟页映射到相同的物理页，任何线程对该页的读写都会影响到其他线程的状态。
- 关于 files: 内核通过描述符表、文件表、v-node表来表示打开的文件。描述符表是对文件表的引用，v-node表用于记录文件表的元信息。父进程创建子进程时，会为子进程创建一份描述符表的原样拷贝。主线程创建对等线程时，会共享同一个描述符表。