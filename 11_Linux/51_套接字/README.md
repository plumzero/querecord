

## I/O操作的原理
- 对于Linux操作系统而言，网络I/O和本地磁盘I/O本质上是一样的。一次网络I/O过程如下:
  <h1 align="center">
    <img width="732" height="383" src=".resource/底层数据通信.jpg">
  </h1>
- 这里主要涉及到用户程序、操作系统Kernel、硬件设备三层，整体操作过程为：
    1. 用户程序A发起I/O操作；
    2. 操作系统Kernel通过底层硬件设备检查I/O是否就绪（对于写入方，是否与接收方已完成通信链路连接；对于接收方，是否有数据到达）；
    3. 如果未就绪，则进行未就绪时的处理方式；如果已就绪(后绪讲到)，对于接收方，将数据从硬件设备读取到操作系统Kernel，然后再从操作系统Kernel读取到用户程序空间，完成读取操作；对于写入方，将数据从用户程序空间写入操作系统Kernel，然后再将操作系统Kernel中的数据写入硬件设备，以进行向远端的网络传输。
- 对于第 3 步未就绪的情况，操作系统此时有两种可选的处理方式:
    1. 操作系统挂起用户程序，切换到其他操作，等就绪了再唤醒用户程序：从调用方的角度看，此时用户程序的调用被阻塞了；
    2. 操作系统不挂起用户程序，直接返回未就绪状态给用户程序：从调用方的角度看，此时用户程序的调用并没有被阻塞，只是状态为未就绪而已。
- 接下来我们考虑当I/O就绪状态下，数据在用户程序与操作系统Kernel间的传递方式（以读取数据为例，写入数据类似），依然有两种可选的方式：
    1. 用户程序等待操作系统Kernel将数据从硬件设备读取操作系统Kernel，然后再将数据从操作系统Kernel读取到用户程序空间：从用户程序的角度来看，发起读取数据的调用之后，在调用返回时，就已经获取了需要读取的数据，此为同步；
    2. 用户程序发起读取操作之后，无需向 1 那样等待数据读取完成，而是直接返回。当操作系统Kernel将数据从底层硬件读取过来，并进一步读取到用户程序空间之后，对用户程序进行通知，此时用户程序才对自身空间中的数据进行后续处理，此为异步。
- 通过上边的描述，我们对操作系统处理I/O请求的原理进行了分析，并针对未就绪状态的两种处理方式（阻塞与非阻塞）、就绪状态进行实际I/O操作的两种处理方式（同步与异步）进行了分析。由于阻塞与非阻塞、同步与异步均为用户程序角度进行的定义，个人认为，通过操作系统I/O原理的角度对其进行理解，会更加准确，也不容易造成混淆。

## 同步与异步
- 现在我们从用户程序角度来看一下同步与异步的区别与联系。**同步与异步的区别在于调用方发起调用之后，是否在调用返回的时候就已经得到了结果。**同步的方式，当调用返回时即得到了结果；而异步的方式则是发起调用之后立即返回，此时并没有得到结果，当结果产生了之后，调用方得到通知，从而获取到结果。
- 在计算机科学领域，同步和异步的使用场景都有许多。比如以控制信息或短数据消息为主的RPC调用场景，通常而言会采用同步的方式，因为相对会简单一些且消息体比较短，同步调用时间比较可控；而对于创建订单等响应时间要求严苛的场景，通常会采用异步的方式，首先保证订单中心成功创建订单，然后再异步写MQ，或者通过数据同步的方式（传输流、订阅MySQL Binlog事件），通知其余系统（用户积分系统、用户操作日志系统、商家服务系统、物流配送系统等），然后订单中心接收其他关联系统的反馈消息，根据其他关联系统是否操作成功来进行相应的处理（重新发起请求追同步，或daily任务追同步）。
- 二者比较见下表

|            | 同步 | 异步 |
|:----------:|:----:|:----:|
|调用即时返回| 是   | 否   |
|优点        |简单  |调用过程及时返回|
|缺点        |当调用时间较长时，大并发调用请求要么采用排队，要么需多线程应对，导致响应时间性能受限（前者）或内存占用大（后者）|调用方需全面应对调用失败|
|适用场景|短消息体传输，调用返回时间可控，响应时间要求不严苛|非短消息体传输，调用返回时间不可控，响应时间要求严苛|

## 阻塞与非阻塞
- 现在我们来看一下阻塞与非阻塞。从操作系统的视角来看，阻塞与非阻塞主要体现在I/O未就绪时，操作系统对用户程序的处理。如果操作系统挂起了用户程序，则为阻塞的方式；如果操作系统直接返回了未就绪状态给用户程序，则为非阻塞的方式。
- 二者比较见下表

|    |阻塞|非阻塞|
|:---:|:--:|:---:|
|当I/O未就绪时的行为|挂起，直到I/O就绪|直接返回，返回未就绪状态|
|优点|NA|当使用I/O多路复用时，单线程或开启与CPU核心数相等的线程数即可|
|缺点|由于阻塞，因此需开启多线程应对多个连接，而受限于内存，线程数存在上限；线程创建与销毁存在开销。|NA|
|适用场景|并发连接少|并发连接多|

## I/O多路复用技术
- I/O多路复用技术通常是与非阻塞I/O进行搭配的。
- 如果没有I/O多路复用，非阻塞I/O方式下，当I/O没有就绪时，用户程序会获取操作系统返回的“I/O不就绪”，为了及时得到I/O就绪的反馈，用户程序会不断地进行轮询。这只是一路I/O，为了能够同时监听多路I/O是否就绪，操作系统提供了I/O多路复用机制，封装了对多路I/O的状态监听。
- 以Linux操作系统为例，有`select`、`poll`和`epoll`三种I/O多路复用机制。
- `select`和`poll`采用的是轮询的方式，而`epoll`在`select/poll`的基础上进行了性能的增强，对于大量并发连接中仅有少量活跃连接的场景下，可以有效地提升CPU的利用率。
[select, poll, epoll 之间的区别](https://www.cnblogs.com/aspirant/p/9166944.html)
- 多路复用是为了能够处理更多的连接，而不是更快速的处理业务。

## sockaddr_in 与 sockaddr
- 一般编程中并不直接对sockaddr进行操作，而是对sockaddr_in进行操作。
- sockaddr_in和sockaddr是并列的数据结构，指向sockaddr_in结构体的指针也可以指向sockaddr的结构体，并代替它。
- sockaddr_in结构体中的端口号和IP地址必须使用网络字节序，需要将套接字地址结构赋给函数时候，可以使用强制类型转换将sockaddr_in转换为sockaddr。   
    

【TCP套接字】
通信工作的大致流程如下：
    1.服务器先用socket()函数建立一个套接字，用这个套接字完成通信的监听及数据的收发。
    2.服务器用bind()函数绑定一个端口号和IP地址，使套接字与指定的端口号和IP地址相关联。
    3.服务器调用listen()函数，使服务器的这个端口和IP处于监听状态，等待网络中某一客户端的连接请求。
    4.客户端用socket()函数建立一个套接字，设定远程IP和端口。
    5.客户端调用connect()函数连接远程计算机指定的端口。
    6.服务器调用accept()函数接收远程计算机的连接请求，建立起与客户端之间的通信连接。
    7.建立连接以后，客户端用write()函数（或send()函数）向Socket中写入数据。也可以用read()函数（或recv()函数）读取服务器送来的数据。
    8.完成通信以后，使用close()函数关闭Socket连接。
    
TCP用三次握手和滑动窗口机制保证传输的可靠性并进行流量控制。
    
int listen(int sockfd, int backlog);
如果Socket为AF_INET，则参数backlog的最大值可设为128，即最多可以同时接收128个客户端的请求。

服务器处于监听状态时，如果某时刻获得客户端的连接请求，则当时并未立即处理这个请求，而是将这个请求放在等待队列中，当系统空闲时再处理客户端的连接请求。接收请求的函数是accept()。
    
由于在程序中将IP地址类型设置为"INADDR_ANY"，所以本地计算机既作为服务器，又作为客户端。
    
connect()函数会将本地的Socket连接到serv_addr指定的服务器IP与端口号上。

在网络编程中，当套接字建立连接以后，向这个套接字中写入数据即表示向远程主机发送数据，从套接字中读取数据则相当于接收远程主机发送过来的数据。

在C\S模式中，一个连接由服务器IP、客户端IP、端口号唯一确定，可以调用getsockname()函数获取与某个套接字关联的本地地址，调用getpeername()函数获取与某个套接字
关联的目的地址。
两个网络程序之间的一个网络连接包括5种信息：通信协议、本地协议地址、本地主机端口、远端主机地址和远端协议端口。

使用bind函数时，可以用下面的赋值实现自动获得本机IP地址和随机获取一个没有被占用的端口号：
    my_addr.sin_port = 0;                       //系统随机选择一个未被使用的端口号
    my_addr.sin_addr.s_addr = INADDR_ANY;       //填入本机IP地址
    
仅知道域名是不能直接访问一个主机的，需要转换成相应的IP地址。用域名返回IP地址的函数是gethostbyname()。

int shutdown(int sockfd, int how);

当某个套接字绑定一个端口之后，在默认情况下，该端口无法被其他套接字绑定，执行bind()函数返回的错误代码总是报告试图连接的端口已经被别的进程所绑定，这与默认的
套接字选项有关。为了使多个套接字可以同时绑定同一个端口，可以使用setsockopt()函数来配置套接字选项，与之对应，还可以使用getsockopt()函数来获取套接字选项。
通常使用如下语句来允许一个套接字复用端口：
    /* 设定参数数值，1表示开启，0表示关闭 */
    int opt = 1;
    len = sizeof(opt);
    /* 开启套接字端口复用 */
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, &len);
还可以使用setsockopt()函数来设置众多的套接字选项：
    /* 设定参数数值，1表示允许，0表示不允许 */
    int yes = 1;
    len = sizeof(yes);
    /* 允许套接字接收广播数据 */
    setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(yes));
    
getpeername()函数可以取得一个已经连接上的套接字的远程信息（如IP地址和端口），让我们知道某个套接字目前连接的是哪个服务器。
当拥有了远程连接用户的IP地址以后，就可以使用inet_ntoa()或gethostbyaddr()来输出信息或是做进一步的处理。

gethostname()函数可以取得本地主机的信息，返回正在执行它的计算机的名字，这个名字可以被gethostbyname()函数使用，由此可以得到本地主机的IP地址。
    
I/O模式
当CPU在执行代码（当前活动线程）的过程中遇到一个I/O请求（如调用read()/write()或recv()/send()）时，系统将产生一个中断，当前活动线程阻塞在此，让CPU去完成这个
I/O请求，等到完成后，系统再次产生一个中断使原先的程序继续运行。这就是所谓的同步I/O。如果要反复读/写大文件，同步I/O的效率是很低的。 

当CPU执行代码遇到一个I/O请求时，使用一个线程去处理I/O请求，并且当前调用线程并不挂起。如果后续代码和这个I/O有关（如需要等待I/O操作的结果），它就要等到这个
I/O操作完成。但如果后续代码和这个I/O操作无关，就可以以更快的速度执行下去，而无须等待I/O请求的完成，这就是异步I/O。

为了提高系统性能及程序的并发性，经常要用到异步I/O模式。在Linux网络编程中，select函数、poll函数和epoll函数常被用来实现异步I/O模式。

connect、accept、recv或recvfrom都是阻塞函数，select是一个非阻塞函数。
所谓非阻塞函数，就是进程或线程执行此函数时，不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若
事件没有发生则返回一个回码来告知事件未发生，让进程或线程继续执行，所以效率很高。

int select(int maxfdp, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval * timeout);
timeout是select的超时时间，它可以使select处于如下3种状态：
    1）形参以NULL传入，就是将select置于阻塞状态，一定要等到监视文件描述符集合中某个文件描述符发生变化为止；
    2）设为零秒零毫秒，就变成了一个纯粹的非阻塞函数，执行后立刻返回。文件无变化返回零，有变化则返回一个正值；
    3）timeout值大于零，这就是等待的超时时间，即select在timeout内阻塞，超时间内有事件到来立即返回，否则超时一过一定返回，返回值同上。
    
网络字节序使用的是大端模式。
在TCP/IP网络中，用到的IP是以"."隔开的的十进制的数（如192.168.1.1），而在套接字的数据结构中用的则是32位的网络字节序的二进制数值。
    
#include <netdb.h>
struct hostent *gethostbyname(const char *hostname);
struct hostent *gethostbyaddr(const char *addr, size_t len, int family);
gethostbyname()函数实现域名或主机名到IP地址的转换，参数hostname指向存放域名或主机名的字符串。
gethostbyaddr()函数实现IP地址到域名或主机名的转换。通常，参数addr指向含有IP地址的字符串，参数len是此字符串的大小，参数family为协议族。

struct hostent
{
    char *h_name;       /*主机的正式名称*/
    char **h_aliases;   /*主机的别名*/
    int h_addrtype;     /*主机的地址类型，IPv4为AF_INET*/
    int h_length;       /*地址长度，对于IPv4是4字节，即32位*/
    char **h_addr_list; /*主机的IP地址列表 整数表示*/
};
#define h_addr h_addr_list[0]   /*主机的第一个IP地址*/

## 参考
- [I/O操作 -- 同步与异步，阻塞与非阻塞](https://blog.csdn.net/u011497622/article/details/81272297)