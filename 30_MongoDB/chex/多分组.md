
```sql
    CREATE TABLE mast
    (
        settle  INTEGER,
        float   REAL,
        cfg     INTEGER,
        yprice  REAL,
        account INTEGER,
        trader  CHAR(16),
        symbol  CHAR(16),
        mkt     INTEGER,
        time    INTEGER
    );
```

```sql
    INSERT INTO mast VALUES
        (1000, 10.1, 100, 20.12, 1001, 'trader-10', '600062.SH', 2012, 150000),
        (1100, 5.22, 200, 23.97, 1001, 'trader-01', '300534.SZ', 4794, 150000),
        (1700, 6.38, 700, 13.25, 1001, 'trader-01', '002750.SZ', 9275, 150000),
        (1200, 9.87, 500, 13.25, 1001, 'trader-02', '002750.SZ', 6625, 150000),
        (1500, 12.3, 300, 38.27, 1001, 'trader-01', '300052.SZ', 11481, 150000),
        (1600, 22.4, 400, 20.56, 1001, 'trader-01', '300364.SZ', 8224, 145900),
        (1500, 12.3, 300, 38.27, 1002, 'trader-07', '300052.SZ', 11481, 150000),
        (1100, 5.22, 200, 23.97, 1002, 'trader-01', '300534.SZ', 4794, 150000),
        (1600, 22.4, 400, 20.56, 1002, 'trader-01', '300364.SZ', 8224, 145900),
        (1100, 5.22, 200, 23.97, 1002, 'trader-02', '300534.SZ', 4794, 150000),
        (1100, 5.22, 200, 23.97, 1002, 'trader-03', '300534.SZ', 4794, 150000);
```

```sql
    CREATE TABLE ranks
    (
        symbol  CHAR(16),
        rank    INTEGER
    );
```

```sql
    INSERT INTO ranks VALUES
        ('600062.SH', 2),
        ('002750.SZ', 200),
        ('300052.SZ', 203),
        ('300364.SZ', 204),
        ('300534.SZ', 501);
```


描述:
- 筛选出 time 为 150000 的记录。
- 之后以 account 进行分组，统计各 account 拥有的 symbol 数量。
- 计算出各 account 中 cfg × yprice 之和。
- 计算出各 account 中 symbol 位于 rank 前 500 的 (settle + float) 的加和及 mkt 的加和。

思路: 分步式考虑。先生成小的临时表/工具表，之后大表内联小表或者小表内联小表生成完成表。

1. 针对 mast 表筛选出 time 为 150000 的记录:
```sql
    SELECT * FROM mast WHERE time = 150000;
```

2. 以 1 产生的表作为临时表 t，对其进行分组。分组字段为 account 和 symbol，生成临时表 w:
```sql
    SELECT t.account, t.symbol
        FROM (
            SELECT * FROM mast WHERE time = 150000
        ) AS t GROUP BY t.account, t.symbol;
```

3. 对临时表 w 再进行 account 分组，得到最终需要的工具表 x:
```sql
    SELECT w.account, COUNT(*) AS "totalOPSC"
        FROM (
            SELECT t.account, t.symbol
                FROM (
                    SELECT * FROM mast WHERE time = 150000
                ) AS t GROUP BY t.account, t.symbol
        ) AS w GROUP BY w.account;
```
输出结果如下:
```sh
 account | totalOPSC 
---------+-----------
    1001 |         4
    1002 |         2
```

4. 再回到 mast 表，筛选出 time 为 150000 的记录，统计各 account 的 (cfg * yprice) 之和。得到工具表 y:
```sql
    SELECT m.account, SUM(m.cfg * m.yprice) AS "totalOPM"
        FROM mast AS m
            WHERE m.time = 150000
                GROUP BY m.account;
```
输出结果如下:
```sh
 account |      totalOPM      
---------+--------------------
    1001 |  34187.00008392334
    1002 | 25862.999725341797
```

5. 再回到 mast 表，内联 ranks 表。筛选出 time 为 150000 且 rank 不大于 500 的记录，视为临时表 v:
```sql
    SELECT m.*, r.rank
        FROM mast AS m
            INNER JOIN ranks AS r
                ON m.symbol = r.symbol
                    WHERE m.time = 150000 AND r.rank <= 500;
```

6. 对临时表 v 进行 account 分组，计算 (settle + float) 的加和。得到工具表 z:
```sql
    SELECT v.account, SUM(v.mkt) AS "totalFM500", SUM(v.settle + v.float) AS "totalFP500"
        FROM (
            SELECT m.*, r.rank
                FROM mast AS m
                    INNER JOIN ranks AS r
                        ON m.symbol = r.symbol
                            WHERE m.time = 150000 AND r.rank <= 500
        ) AS v GROUP BY v.account;
```
输出结果如下:
```sh
 account | totalFM500 |     totalFP500     
---------+------------+--------------------
    1001 |      29393 |  5438.650000572205
    1002 |      11481 | 1512.3000001907349
```

7. 最后内联 x, y, z 表，得到最终结果:
```sql
    SELECT x.account AS "账户", x."totalOPSC" AS "总数量", y."totalOPM" AS "总值", z."totalFM500" AS "FM500", z."totalFP500" AS "FP500"
        FROM (
            SELECT w.account, COUNT(*) AS "totalOPSC"
                FROM (
                    SELECT t.account, t.symbol
                        FROM (
                            SELECT * FROM mast WHERE time = 150000
                        ) AS t GROUP BY t.account, t.symbol
                ) AS w GROUP BY w.account
        ) AS x
            INNER JOIN (
                SELECT m.account, SUM(m.cfg * m.yprice) AS "totalOPM"
                    FROM mast AS m
                        WHERE m.time = 150000
                            GROUP BY m.account
            ) AS y ON x.account = y.account
            INNER JOIN (
                SELECT v.account, SUM(v.mkt) AS "totalFM500", SUM(v.settle + v.float) AS "totalFP500"
                    FROM (
                        SELECT m.*, r.rank
                            FROM mast AS m
                                INNER JOIN ranks AS r
                                    ON m.symbol = r.symbol
                                        WHERE m.time = 150000 AND r.rank <= 500
                    ) AS v GROUP BY v.account
            ) AS z
                ON x.account = z.account;
```

用 MongoDB 实现同样的效果:

```js
    db.mast.insertMany([
        { settle: 1000, float: 10.1, cfg: 100, yprice: 20.12, account: 1001, trader: 'trader-10', symbol: '600062.SH', mkt: 2012, time: 150000 },
        { settle: 1100, float: 5.22, cfg: 200, yprice: 23.97, account: 1001, trader: 'trader-01', symbol: '300534.SZ', mkt: 4794, time: 150000 },
        { settle: 1700, float: 6.38, cfg: 700, yprice: 13.25, account: 1001, trader: 'trader-01', symbol: '002750.SZ', mkt: 9275, time: 150000 },
        { settle: 1200, float: 9.87, cfg: 500, yprice: 13.25, account: 1001, trader: 'trader-02', symbol: '002750.SZ', mkt: 6625, time: 150000 },
        { settle: 1500, float: 12.3, cfg: 300, yprice: 38.27, account: 1001, trader: 'trader-01', symbol: '300052.SZ', mkt: 11481, time: 150000 },
        { settle: 1600, float: 22.4, cfg: 400, yprice: 20.56, account: 1001, trader: 'trader-01', symbol: '300364.SZ', mkt: 8224, time: 145900 },
        { settle: 1500, float: 12.3, cfg: 300, yprice: 38.27, account: 1002, trader: 'trader-07', symbol: '300052.SZ', mkt: 11481, time: 150000 },
        { settle: 1100, float: 5.22, cfg: 200, yprice: 23.97, account: 1002, trader: 'trader-01', symbol: '300534.SZ', mkt: 4794, time: 150000 },
        { settle: 1600, float: 22.4, cfg: 400, yprice: 20.56, account: 1002, trader: 'trader-01', symbol: '300364.SZ', mkt: 8224, time: 145900 },
        { settle: 1100, float: 5.22, cfg: 200, yprice: 23.97, account: 1002, trader: 'trader-02', symbol: '300534.SZ', mkt: 4794, time: 150000 },
        { settle: 1100, float: 5.22, cfg: 200, yprice: 23.97, account: 1002, trader: 'trader-03', symbol: '300534.SZ', mkt: 4794, time: 150000 },
    ])
```

```js
    db.ranks.insertMany([
        { symbol: '600062.SH', rank: 2 },
        { symbol: '002750.SZ', rank: 200 },
        { symbol: '300052.SZ', rank: 203 },
        { symbol: '300364.SZ', rank: 204 },
        { symbol: '300534.SZ', rank: 501 },
    ])
```

```js
    db.mast.aggregate([
        {
            $match: { time: 150000 }
        },
        {
            $lookup: {
                from: 'ranks',
                localField: 'symbol',
                foreignField: 'symbol',
                as: 'ranks'
            }
        },
        {
            $unwind: '$ranks'
        },
        {
            $replaceRoot: { newRoot: { $mergeObjects: [ '$ranks', '$$ROOT' ] } }
        },
        {
            $group: {
                _id: {account:'$account', symbol:'$symbol'},
                OPM: { $sum: '$mkt' },
                FM500: { $sum: { $cond: { if: {$lte: ['$rank', 500]}, then: '$mkt', else: 0 } } },
                FP500: { $sum: { $cond: { if: {$lte: ['$rank', 500]}, then: { $add: ['$settle', '$float'] }, else: 0 } } }
            }
        },
        {
            $group: {
                _id: '$_id.account',
                totalOPM: { $sum: '$OPM' },
                totalOPSC: { $sum: 1 },
                totalFM500: { $sum: '$FM500' },
                totalFP500: {$sum: '$FP500' }
            }
        }
    ])
```
要进行两次 group 操作，对应两次 JOIN 。
输出结果如下:
```sh
{ "_id" : 1002, "totalOPM" : 25863, "totalOPSC" : 2, "totalFM500" : 11481, "totalFP500" : 1512.3 }
{ "_id" : 1001, "totalOPM" : 34187, "totalOPSC" : 4, "totalFM500" : 29393, "totalFP500" : 5438.65 }
```

SQL 看似复杂，拆分下来反而比 MongoDB 更容易理解一些。

```sql
    SELECT x.id AS "id", x."totalOPSC" AS "amount", y."totalOPM" AS "value", z."totalFM500" AS "FM500", z."totalFP500" AS "FP500"
        FROM (
            SELECT w.id, COUNT(*) AS "totalOPSC"
                FROM (
                    SELECT t.id, t.s
                        FROM (
                            SELECT * FROM mast WHERE time = 150000
                        ) AS t GROUP BY t.id, t.s
                ) AS w GROUP BY w.id
        ) AS x
            INNER JOIN (
                SELECT m.id, SUM(m.cfg * m.price) AS "totalOPM"
                    FROM mast AS m
                        WHERE m.time = 150000
                            GROUP BY m.id
            ) AS y ON x.id = y.id
            INNER JOIN (
                SELECT v.id, SUM(v.mkt) AS "totalFM500", SUM(v.settle + v.float) AS "totalFP500"
                    FROM (
                        SELECT m.*, r.rank
                            FROM mast AS m
                                INNER JOIN ranks AS r
                                    ON m.s = r.s
                                        WHERE m.time = 150000 AND r.rank <= 500
                    ) AS v GROUP BY v.id
            ) AS z
                ON x.id = z.id;
```
