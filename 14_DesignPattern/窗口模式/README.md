
## 说明
- 程序这东西总是会变得越来越大。随着时间的推移，程序中的类会越来越多，而且它们之间相
  互关联，这会导致程序结构也变得越来越复杂。我们在使用这些类之前，必须先弄清楚它们之
  间的关系，注意正确的调用顺序。
- 特别是在调用大型程序进行处理时，我们需要格外注意那些数量庞大的类之间错综复杂的关系。
  不过与其这么做，不如为这个大型程序准备一个"窗口"。这样，就不必单独地关注每个类了，
  只需要简单地对"窗口"提出请求即可。
- 这个"窗口"就是 Facade 模式。
- 使用 Facade 模式可以为互相关联在一起的错综复杂的类整理出高层接口(API)。其中的 Facade
  角色可以让系统对外只胡一个简单的接口(API)。而且，Facade 角色还会考虑到系统内部各个类
  之间的责任关系和依赖关系，按照正确的顺序调用各个类。

## realize 实现
- 窗口模式常常应用于将底层相互之间没有关联的类，统一于上层的应用类中。底层角色各自完成
  自己的工作，它们并不知道 Facade 角色。Facade 角色调用其他角色进行工作，但是其他角色
  不会调用 Facade 角色(但不尽然，也可能会传入 Facade 角色指针以使 Facade 角色中的某些
  成员供底层角色使用，如日志句柄。不过无论如何，底层角色都不应该调用 Facade 角色中的方
  法)。
- 平时如果稍加留意的话，会发现很多项目会用到这种模式。
- 此种模式比较简单，不做详述。

## 相关的设计模式
- Abstract Factory 模式
    + 可以将 Abstract Factory 模式看作生成复杂实例时的 Facade 模式。因为它提供了"要想生
      成这个实例只需要调用这个方法就 OK 了"的简单接口。
- Singleton 模式
    + 有时会使用 Singleton 模式创建 Facade 角色。
- Mediator 模式
    + 在 Facade 模式中， Facade 角色单方面地使用其他角色来提供高层接口(API)。
    + 而在 Mediator 模式中， Mediator 角色作为 Colleague 角色间的仲裁者负责调停。可以说
      Facade 模式是单向的，而 Mediator 角色是双向的。