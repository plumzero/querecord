在一个有向图 G=(V,E) 中，它的每一条边都有一个比例常数 Weight 与之对应(这种就称为有向网了)，如果想求图 G 中某一个顶点 v0 到其他顶点的最少 Weight 之和，那么这类问题就称为`最短路径问题`。

### 从某个顶点到其余各顶点的最短路径

- 利用 Dijkstra 算法，基本思想是根据路径长度递增求解从 v0 到其他各顶点的最短的路径。
- 假设 S 表示求出的最短路径对应终点的集合。在按递增次序已经求出从顶点 v0 出发到顶点 vi 的最短路径之后，那么下一条最短路径，即`从顶点 v0 到顶点 vk 的最短路径，或者是弧 <v0,vk>，或者是经过集合 S 中某个顶点然后到达顶点 vk 的路径`。
- 利用 Dijkstra 算法求解最短路径的步骤如下(邻接矩阵存储有向图):
    1. 初始时，S 只包括源点 v0, 即 S={v0}, V-S 包括除 v0 以外的图中的其他顶点。定义一个一维数组 dist，其下标对应值用于保存 v0 到其他各顶点的最短路径。v0 到其他顶点的路径初始化为 dist[i]=G.arc[0][i].adj。
    2. 选择距离顶点 vi 最短的顶点 vj, 使得 dist[j]=Min{dist[i] | vi∈V-S}。dist[j] 表示从 v0 到 vj 最短路径长度，vj 表示对应的终点。
    3. 修改从 v0 到顶点 vi 的最短路径长度，其中 vi∈S。如果有 dist[k]+G.arc[k][i]<dist[i]，则修改 dist[i]，使得 dist[i]=dist[k]+G.arc[k][i].adj 。
    4. 重复执行 2 和 3，直到所有从 v0 到其他顶点的最短路径长度求出。


### 每一对顶点之间的最短路径

- 如果要计算每一对顶点之间的最短路径，只需要以任何一个顶点为出发点，将 Dijkstra 算法重复执行 n 次，就可以得到每一对顶点的最短路径。这样求出的每一个顶点之间的最短路径的时间复杂度为 O(n^3)。
- 另一种求每一对顶点之间的最短路径的 Floyd 算法，其时间复杂度也是 O(n^3) 。
- 求解各个顶点之间最短路径的 Floyd 算法思想

    1. 假设要求顶点 vi 到顶点 vj 的最短路径。如果从顶点 vi 到顶点 vj 存在弧，但是该弧所在的路径不一定时 vi 到 vj 的最短路径，需要进行 n 次比较。首先需要从顶点 v0 开始，如果有路径 (vi,v0,vj) 存在，则比较路径 (vi,vj) 和 (vi,v0,vj)，选择两者中最短的一个且中间顶点的序号不大于0。
    2. 然后在路径上再增加一个顶点 v1, 得到路径(vi,...,v1)和(v1,...vj)，如果两者都是中间顶点不大于0的最短路径，则将该路径(vi,...v1,...,vj)与上面的已经求出的中间顶点序号不大于0的最短路径比较，选其中最小的作为从 vi 到 vj 的中间路径顶点序号不大于 1 的最短路径。
    3. 接着在路径上增加顶点 v2, 得到路径(vi,...,v2)和(v2,...,vj)，按照以上方法进行比较，求出从 vi 到 vj 的中间路径顶点序号不大于 2 的最短路径。依次类推，经过 n 次比较，可以得到从 vi 到 vj 的中间顶点序号不大于 n-1 的最短路径。
    
    依照这种方法，可以得到各个顶点之间的最短路径。
