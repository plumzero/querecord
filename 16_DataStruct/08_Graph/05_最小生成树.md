
### 无向图的连通分量与生成树

- 对非连通图进行深度或广度优先遍历，就可以分别得到连通分量的顶点序列。
- 对于连通图，从某一个顶点出发，对图进行深度优先遍历，按照访问路径得到一棵生成树，称为`深度优先生成树`。
- 对于连通图，从某一个顶点 ∅ 出发，对图进行广度优先遍历，得到的生成树称为`广度优先生成树`。
- 对于非连通图而言，从某一个顶点出发，对图进行深度优先遍历或者广度优先遍历，按照访问路径会得到一系列的生成树，这些生成树在一起构成生成森林。
- 利用图的深度优先或广度优先遍历，可以判断一个图是否是连通图。如果不止一次的调用遍历图，则说明该图是非连通的，否则该图是连通图。

### 最小生成树

最小生成树就是指在一个`连通网`的所有生成树中所有边的代价之和最小的那棵生成树。代价在网中通过权值来表示，一个生成树的代价就是生成树各边的代价之和。

最近又看到了一个关于生成树的说法，希望能够帮助理解:
> 生成树又称为'花费树'、'成本树' 或 '值树'，一个图的生成树就是以最少的边来连通图中所有的顶点，且不造成回路的树结构。为树的边加上一个权重值，
> 这种图就称为`加权图`。如果这个权重值代表两个顶点间的`距离`或`成本`，这类图就被称为`网络`。

可以通过 `普里姆算法` 或者 `克鲁斯卡尔算法` 在一个加权图中找到它的最小生成树。

> 再次强调: 用于构造最小生成树的图必须是连通的。

### 普里姆算法

假设 N={V,E} 是连通网，TE 是 N 的最小生成树边的集合。执行以下操作:
1. 初始时，令 U={u0}(u0∈V),TE=空集。
2. 对于所有的边 u∈U,v∈V-U的边(u,v)∈E，将一条代价最小的边(u0,v0)放到集合TE中，同时将顶点v0放进集合U中。
3. 重复执行步骤2，直到U=V为止。
这时，边集合 TE 一定有 n-1 条边，T={V,TE}就是连通网N的最小生成树。

以下图为例进行分析: 
```s
    A----7----D
    |         |
    6         6
    |         |
    B----8----C
```
- 起始时 U={},V-U={A,B,C,D},TE={}。
- 假设从顶点 A 开始构造最小生成树，U={A}。A 的邻接点有 B 和 D，对应的边有 (A,B) 和 (A,D)，其中最小的边是(A,B)，将 B 加入到 U 中，将(A,B)加入到 TE 中。这时结果为 U={A,B},V-U={C,D},TE={(A,B)}。
- U 中顶点与 V-U 中顶点在图中所构成的边有 (B,C),(A,D), 最小的边是(A,D)，将 D 加入到 U 中，(A,D)加入到 TE 中。这时结果为 U={A,B,D},V-U={C},TE={(A,B),(A,D)}。
- U 中顶点与 V-U 中顶点在图中所构成的边有 (B,C),(D,C), 最小的边是(D,C)，将 C 加入到 U 中，(D,C)加入到 TE 中。这时结果为 U={A,B,D,C},V-U={},TE={(A,B),(A,D),(D,C)}。
- 此时 U=V，整个执行过程结束。

算法实现分析
- 将 U 中顶点与 V-U 中顶点在图中所构成的所有的边进行比较，获取代价最小的边。将该边的在 V-U 中的点从 V-U 中去除，并加入到 U 中，并将该边加入到 TE 中。
- 对于上述所有的边，可以将它们存入一个结构数组进行比较，数组下标记录 V-U 中顶点序号，数组内容记录该顶点与 U 中顶点所构成的代价最小边，以及该边顶点(∈U)中的相关信息。
  ```c
    CloseEdge[v].lowcost = Min({cost(u, v) | u∈U, v∈V-U})
  ```

### 克鲁斯卡尔算法

假设 N={V,E} 是连通网，TE 是 N 的最小生成树边的集合。执行如下操作:
1. 初始时，最小生成树中只有 n 个顶点，这 n 个顶点分别属于不同的集合，而边的集合 TE=∅。
2. 从连通网 N 中选择一个代价最小的边，如果边所依附的两个顶点在不同的集合中，将该边加入到最小生成树 TE 中，并将该边依附的两个顶点合并到同一个集合中。
3. 重复执行步骤2，直到所有的顶点都属于同一个顶点集合为止。

以下图为例进行分析: 
```s
  A----7----D
  |         |
  6         6
  |         |
  B----8----C
```
- 起始时，各顶点分属于不同的集合，边的集合为空集。有 U1={A},U2={B},U3={C},U4={D},TE={}。
- 一共有 4 条边，将这 4 条边按从小到大排列。
- 最小的边为(A,B),顶点 A 和 B 分属于不同的集合，将 (A,B) 加入到 TE 中，合并集合 U1, U2, 此时有 U1={A,B},TE={(A,B)}。
- 剩余最小的边是(D,C), 且 D 和 C 分属于不同集合，执行同样操作，此时有U3={C,D}, TE={(A,B),(C,D)}。
- 剩余最小的边是(A,D), 且 A 和 D 分属于不同集合，执行同样操作，此时有U1={A,B,C,D},TE={(A,B),(C,D),(A,D)}。
    
### 两种算法比较

- 复杂度: 普 > 克
- 适用性: 普 > 克
