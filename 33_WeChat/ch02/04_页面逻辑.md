
在项目中，pages/index/index.js 文件用于编写页面逻辑。在这种页面中，会有一个 Page() 函数，用来注册一个页面，该函数的参数是一个对象，通过该对象可以指定页面的初始数据、生命周期函数、事件处理函数等。

Page() 函数参数对象的属性:

| 属性 | 类型 | 说明 |
|:----|:-----|:-----|
| data | Object | 页面的初始数据 |
| onLoad | Function | 生命周期回调函数，监听页面加载 |
| onReady | Function | 生命周期回调函数，监听页面初次渲染完成 |
| onShow | Function | 生命周期回调函数，监听页面显示 |
| onHide | Function | 生命周期回调函数，监听页面隐藏 |
| onUnload | Function | 生命周期回调函数，监听页面卸载 |
| onPullDownRefresh | Function | 页面事件处理函数，监听用户下拉动作 |
| onReachBottom | Function | 页面事件处理函数，页面上拉触底 |
| onShareAppMessage | Function | 页面事件处理函数，用户单击右上角的分享按钮 |
| onPageScroll | Function | 页面事件处理函数，页面滚动会连续触发 |

### 生命周期回调函数

- `onLoad`: 页面加载时触发，一个页面只会调用一次。通过参数 options 可以获取打开当前页面路径中的参数。
- `onReady`: 页面初次渲染完成的时候调用。一个页面只会调用一次，代表页面已经准备妥当，此时可以与视图层进行交互。
- `onShow`: 当页面显示时触发。例如，从后台切入前台时触发。
- `onHide`: 当页面隐藏时触发。例如，从前台切入后台时触发。
- `onUnload`: 页面卸载时触发。例如，使用路由 API 中的 wx.redirectTo() 或 wx.navigateBack() 跳转其他页面时触发。

在 onLoad 函数中，有一个参数 `options`，表示打开当前页面路径中的参数，它可以在当前页面被其他页面打开的情况下接收一些参数。

### 页面事件处理函数

- `onPullDownRefresh`: 需要在配置文件中将 `enablePullDownRefresh` 设为 true 才会有效。
- `onPageScroll`: 开发者工具没有自动生成这个函数，需要手动添加该函数，并且为了使该函数触发，还需要确保页面的内容高度超过了显示区域，使页面中出现滚动条。

### 组件事件处理函数

组件事件处理函数用于为组件绑定事件，例如，在 pages/index/index.wxml 文件中给 button 组件绑定 `tag` 事件，事件处理函数为 compare:
```xml
    <button bindtap="compare">比较</button>
```

在 pages/index/index.js 中增加 compare 函数:
```js
    compare: function(e) {
        console.log('被单击了', e)
    }
```
通过事件对象 e, 可以获取 `type`(事件类型)、`timestamp`(事件生成时的时间戳)、`target`(触发事件的组件的一些属性值集合)、`currentTarget`(当前组件的一些属性值集合)、`detail`(额外的信息)等信息。

视图层中，组件可以绑定多种事件，常用事件如下:

| 事件类型 | 触发条件 |
|:--------|:---------|
| touchstart | 手指触摸动作开始 |
| touchmove | 手指触摸后移动 |
| touchcancel | 手指触摸动作被打断，如来电提醒、弹窗 |
| touchend | 手指触摸动作结束 |
| tap | 手指触摸后马上离开 |
| longpress | 手指触摸后，超过 350ms 再离。如果指定了事件回调函数并触发了这个事件，tag 事件将不被触发 |

除了上面的事件外，一些组件还拥有一些专门的事件，如 form 组件的 submit 事件、input 组件的 input 事件等。

在为组件绑定事件时，有两种方式，分别是 `bind 事件类型` 和 `catch 事件类型`。bind 方式如 bindtap，它不会阻止冒泡事件向上冒泡，而 catch 可以阻止冒泡事件向上冒泡。
```xml
    <view bindtap="outerTap">
        outer
        <view catchtap="middleTap">
            middle
            <view bindtap="innerTap"></view>
        </view>
    </view>
```
上述代码中，如果单击 inner，会先后触发 innerTap 和 middleTap，由于 middleTap 使用 catch 阻止了事件冒泡，因此不会执行 outerTap 。同理，如果单击 middle, 则只会触发 middleTap 。如果单击 outer，则只会触发 outerTap 。

