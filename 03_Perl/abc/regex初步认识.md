
*以为 awk 很强？ 那是因为还没遇到 Perl。*

*最强之人已在阵中，只是还没发现。*


### 前言

正则表达式在 Perl 里面通常也叫做模式(pattern)。

**注意，要匹配的目标串必须最好使用双引号括起来，否则会出现糟糕的事情。**

### 特殊变量 @_

Perl 中，@_ 除了代表默认输入外，也代表模式匹配内容。

以一个简单模式匹配为例:
```pl
    $str = "yabba dabba doo";

    if ($str =~ /abba/) {
        print "It matched!\n";
    } else {
        print "Not matched!\n";
    }
```

上面的程序就等价于:
```pl
    $_ = "yabba dabba doo";

    if (/abba/) {
        print "It matched!\n";
    } else {
        print "Not matched!\n";
    }
```
在 if 判断中 `/abba/` 默认会去 $_ 中寻找字符进行匹配。第一处代码会将匹配的操作对象绑定为 $str  ，而第二处代码则是直接给 $_ 赋值。二者执行效果是一样的。

下面的写法则是错误的:
```pl
    $str = "yabba dabba doo";

    if (/abba/) {
        print "It matched!\n";
    } else {
        print "Not matched!\n";
    }
```

[示例程序](../R/special_variable.pl)

另外，则于模式匹配通常返回真或假值，所以往往会用在 if 或 while 的条件表达式里。


### Unicode 属性

就像变量不仅有长度还有类型信息一样，字符除了字节组合之外，还带有属性信息。

所以除了根据字符本身匹配之外，还可以根据字符的属性来达成匹配。


### 元字符

模式匹配中代表特殊含义的字符，通过它们使模式匹配不再局限于简单匹配。

| 元字符 | 描述 |
|:------:|:-----|
|   .    | 匹配除换行符以外的所有字符 |
|   \d   | 匹配一个数字字符,和 [0-9] 语法一样 |
|   \D   | 非数字 |
|   \w   | 英文字母或数字的字符串,和 [a-zA-Z0-9_] 语法一样 |
|   \W   | 非英文字母或数字的字符串,和 [^a-zA-Z0-9_] 语法一样 |
|   \s   | 空格,和 [\n\t\r\f] 语法一样 |
|   \S   | 非空格,和 [^\n\t\r\f] 语法一样 |
|   \b   | 匹配由 \w 字符构成的字符串 |
|   \B   | 匹配由 \W 字符构成的字符串 |

如果希望匹配到元字符本身，可以通过 '\' 进行转义。另外，'\' 也是一个元字符。

在正则表达式中，圆括号 `()` 的作用是对字符串分组，因此，圆括号也是元字符。

[示例程序](../R/metacharacter.pl)


### 量词

模式匹配中常常需要重复某些东西，而星号(`*`)正是用来匹配前面的条目零次或多次的。比如 `/fred\t*barney/` 能匹配 fred 和 barney 之间任意数量的制表符。

为什么要使用 `*` 这个符号代表重复多次，这是因为 `*` 是乘法(times)操作符，而英语里"times"也有"次数"的意思。

`/fred\t*barney/` 只能匹配中间有多个制表符的情况，如果制表符里面还夹杂着其他的符号，那么就会匹配失败。而通过 `.*` 则可以匹配任意字符。

量词及描述:

| 量词   | 描述 |
|:------:|:-----|
|   x*   | 贪婪匹配 0 次或多次 |
|   x+   | 贪婪匹配 1 次或多次 |
|   x?   | 匹配 0 次或一次 |
|   {m}  | 匹配刚好是 m 个 的指定字符串 |
| {m,n}  | 匹配在 m个 以上 n个 以下 的指定字符串 |
|   {m,} | 匹配 m个 以上 的指定字符串 |

`+` 或 `*` 后跟 `?` 表示惰性匹配，即尽可能少的匹配，如`*?` 重复任意次，但尽可能少重复。

[示例程序](../R/quantifier.pl)


### 模式分组

在正则表达式中，圆括号 `()` 的作用是对字符串分组。

模式 `/fred+/` 会匹配像 `freddddddd` 这样的字符串，但这种状况并不常见。不过，模式 `/(fred)+/` 会匹配像 `fredfredfred` 这样的字符串，这种状况却很常见。

通过模式分组，可以引用到目标串中符合模式串的字符串，这称为**反向引用**。而目标串中匹配到的字符串则称为**捕获组**。

反向引用的写法是在反斜线后面接上数字编号，比如 `\1`, `\2` 这样。相应的数字代表着对应顺序的捕获组。

```pl
    $_ = "abba";
    if (/(.)\1/) {
        print "It matched same character next to itself!\n";
    }
```
`(.)\1` 表示要匹配连续出现的两个同样的字符。

反向引用不必紧接在对应的捕获组括号后面。下面的模式会匹配 y 后面的 4 个连续的非换行符，并用 `\1` 反向引用表示匹配 d 后也出现这 4 个字符的情况:
```pl
    $_ = "yabba dabba doo";
    if (/y(....) d\1/) {
        print "It matched the same after y and d!\n";
    }
```

也可以用多个括号来分成多组，每组都可以有自己的反向引用。
```pl
    $_ = "yabba dabba doo";
    if (/y(.)(.)\2\1/) {
        print "It matched after the y!\n";
    }
```
这里会匹配到 'abba'。

该如何区分哪个括号是第几组呢？依次点算左括号(包括嵌套括号)的序号就可以了:
```pl
    $_ = "yabba dabba doo";
    if (/y(.)(.)\3\2 d\1/) {
        print "It matched!\n";
    }
```
会匹配到 `\1 = abba \2 = a \3 = b`。


### 择一匹配

竖线 '|' 的意思是要么匹配左边的内容，要么匹配右边的内容。
```pl
    /fred(and|or)barney/        # 匹配 fredandbarney 或 fredorbarney
```

所以啊，`|` 也是特殊字符!

### 字符集

指的是一组可能出现的字符，通过写在方括号 `[]` 内表示。它只匹配单个字符，但可以是字符集中列出的任何一个。

可以使用连字符 `-` 表示始末范围，比如 `[abcwxyz]` 也可以写成 `[a-cw-z]` 。

定义字符集时可以使用字符简写，类似双引号内的转义序列，因此字符集合 `[\000-\177]` 将会匹配任意一个 7 位的 ASCII 字符。

可以在字符集开头的地方加上脱字符 `^` 来表示这些字符除外。比如 `[^def]` 会匹配这三个字符以外的任何字符，而 `[n\-z]` 则会匹配 n、连字符与 z 以外的任何字符。

注意: 字符集 `[]` 里面的连字符 `-` 在使用本义时需要转义，而 `-` 用在 `[]` 外面时则不需要转义。

```pl
    $_ = "The HAL-9000 requires authorization to continue";
    if (/HAL-[0-9]+/) {
        print "The string mentions some model of HAL computer.\n";
    }
```
