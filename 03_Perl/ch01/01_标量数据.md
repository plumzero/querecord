
perl 是一种弱类型语言。标量是 perl 里面最简单的一种数据类型。

perl 的标量有两种: 数字和字符串。


### 数字

perl 内部并不存在整数值，程序中用到的整型常量会被转换成等效的浮点数值。

perl 允许使用十进制(decimal)以外的其他进制来表示数字。八进制(octal)直接以 `0` 开头，十六进制(hexadecimal)直接以 `0x` 开头，而二进制(binary)直接则以 `0b` 开头。
```s
  0377        # 八进制的 377, 等于十进制的 255
  0xff        # 十六进制的 FF, 也等于十进制的 255
  0b11111111  # 也等于十进制的 255
```


### 字符串

需要注意的是单引号内的字符串直接量和双引号内的字符串直接量。

双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出。

单引号输出多行字符串:
```pl
  $string = '
    Hello
      World
  ';
```

> 连接操作符

字符串可以用 `.` 操作符连接起来。

字符串与数字之间的连接:
```pl
  $str = "hello" . "world";       # 字符串连接
  $num = 5 + 10;                  # 两数相加
  $mix = $str . $num;             # 连接字符串和数字
```

需要注意的是，连接运算必须显式使用连接操作符，而不像其他某些语言只需把两个字符串放在一起就行。

> 重复操作符

通过小写字母 `x` 将其左边的操作数(也就是要重复的字符串)与它本身重复连接，重复次数则由右边的操作数(某个数字)指定。
```pl
  "fred" x 3      # fredfredfred
```

> 数字与字符串之间的自动转换

通常 perl 会根据需要，自动在数字和字符串之间进行类型转换。至于它究竟是如何知道需要数字还是字符串，这完全取决于操作符。如果操作符(比如+)需要的是数字，perl 就会将操作数视为数字；在操作符(比如 .)需要字符串时，perl 便会将操作数视为字符串。

因此，你不必担心数字和字符串的差异，只管合理使用操作符，perl 会自动完成剩下的工作。
```pl
  "Z" . 5 * 7     # Z35
```


### 标量变量

就是单单存储一个值的变量。

> 比较操作符

对数值比较时，perl 的比较操作符类似于代数系统: < <= == >= > != 。这些操作符要么是真(true)，要么是假(false)。

perl 对字符串的比较另有一套操作: `lt` `le` `eq` `ge` `gt` `ne` 。
```pl
  if ($name gt 'fred') {
    print "'$name' comes after 'fred' in sorted order.\n";
  }
```

> 布尔值

perl 并没有专用的 "布尔(Boolean)" 数据类型，它是靠一些简单规则来判断的:
- 如果是数字，0 为假，所有其他数字都为真。
- 如果是字符串，空字符串('')为假，所有其他字符串都为真。
- 如果既不是数字也不是字符串，那就先转换成数字或字符串再行判断。

<strong>需要注意的是，字符串 '0' 是唯一被当成假的非空字符串。</strong>


### undef 值

在首将赋值前，变量的初始值是特殊的 `undef` (未定义)值。在标量上下文中，如果当成数字使用，它就会表现得像零；如果当成字符串使用，它就会表现地像空字符串。

但 undef 既不是数字也不是字符串，它完全是另一种类型的标量值。

另外，许多操作符在参数越界或不合理时会返回 undef 。


### defined 函数

行输入操作符 `<STDIN>` 在一般状况下会返回一行文本，但有时也会返回 undef，比如在读到文件结尾(end-of-file)时。

要判断某个字符串是 undef 而不是空字符串，可以使用 defined 函数。如果是 undef ,该函数返回假，否则返回真:
```pl
  $madonna = <STDIN>;
  if (defined($madonna)) {
    print "The input was $madonna";
  }
```