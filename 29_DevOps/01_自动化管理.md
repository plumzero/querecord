
在运维行为中，`自动化`一般用来指代通过编写代码来解决各种各样的问题。更广泛的说，在这一观点中，自动化是"元软件"，也就是操作其他软件的软件。

多数情况下，以软件为基础的自动化是优于手动操作的，但是比这两个选择更好的方案是一个不需要这些的系统设计 —— 一个自治的系统。或者换一种方式来看，自动化的价值不仅来源于它所做的事情，还包括对其的明智应用。

### 自动化的价值

- 一致性: 保证多次运维、操作下都以同样的方式(执行范围明确、步骤已知)进行，避免因为不一致性导致的错误、疏漏、数据质量问题和可靠性问题。
- 平台性: 可以提供一个可以扩展的、广泛适用的平台，从而执行更多的任务。
- 降低修改时间: 平台同时也将错误集中化了，也就是说，在代码中修复某个错误可以保证该错误被永远修复。如果自动化能够始终正常运行，那么就可以降低一些常见故障的平均修复时间(MTTR)。
- 实现快速修复: 在产品生命周期中更早的发现问题，更早的修复，避免后期修复代价提高。
- 提高行动速度: 这是可以想见的。不过要将自动化的范围进行明确定义，在出现问题时及时停止或转为人工干预，避免问题恶化。
- 节省时间: 将任务进行自动化封装，任何人都可以执行它们，有效地将操作与具体操作人解耦。

### 自动化的内容

主要包括:
1. 部署自动化: 包括目标系统用户环境(环境变量、系统函数调用、可用工具等)，系统资源状况、依赖服务版本等。
2. 发布自动化: 可以考虑的内容有源代码管理、编译器版本、配置语言、包管理器和安装器、依赖库等。
3. 配置自动化: 可以考虑的内容有格式正确性校验、内容合理性校验、配置方式(文件/界面/命令行等)。
4. 监控自动化: 可以考虑的方向有服务管理，用来保障服务运行，例如在段错误后重新启动、依赖服务关系的变更；跟踪哪些服务应该运行在哪些机器上；日志消息解析，例如利用正则表达式过滤日志。
5. 回退自动化: 应该考虑的内容包括可执行程序的回退、读写文件的还原、配置和依赖服务的重置等。
   ...

### 自动化分类的层次结构

1. 没有自动化: 操作人员触发手动操作
2. 外部维护的系统特定的自动化系统: 操作人员编写，系统特定的自动化
3. 外部维护的通用的自动化系统
4. 内部维护的系统特定的自动化
5. 不需要任何自动化的系统: 不需要人为干预的自治系统

### 推进使用

不要低估人们对该产品了解程度的难度——通常发一封公告邮件或者做一个简单的演示是不够的。向大型团队推广内部软件工具需要以下几点:
- 持续的和完整的推广方案
- 用户的拥护
- 资深工程师和管理层的赞助，因为他们看到了项目的实用潜力。

在开发过程中，时刻从用户角度出发来设计对提高可用性很重要。

当一个问题领域已经有多年经验的工程师设计一个产品时，我们非常容易陷入对完美的最终产物的幻想中去。但是，给产品设计一个最小成功条件，或者是最小可行产品(MVP)是很重要的。一个工程项目如果承诺了太多、太快，而无法做到，很容易丧失可信度。同时，如果一个项目无法产生出足够有吸引力的结果，可能没有办法找到足够的人来试用。通过递进式的、稳定的、小型发布可以提升用户对项目的信心。

过于通用的框架会带来问题。如果某个工具太过专注于灵活或者通用，很可能无法针对任何一个具体案例产生足够的价值。如果一个项目目标太大、太抽象，很可能需要投入非常大的研发力量，但是却没有足够可靠的实际案例来证明自己的实用性。

### 其他

自动化的内容，主要包括发布、配置和监控三个方面，同时这里也将配置合并到发布里面看待。

对于发布周期比较长的服务，可以忽略发布方面的内容，而以文档的形式代替。对于频繁发布，可以通过 CI/CD 来实现快速迭代，内容包括构建、测试、分析、版本控制、部署等。在每次发布时，这其中的很多内容过程都是重复的。

日常运维的工作主要包括一些周期性或流水线任务，对于服务和系统的监控应该也算是运维的一部分。

通过引入相应的开源工具，可以达到自动化分类的第三个层次。

对于多节点上的发布与运维，利用开源工具通过 SSH 是可以应对繁琐的包分发和服务初始化问题，不过对于配置和服务管理却不方便，很有可能会造成服务与依赖的不同步。而且包分发和服务初始化应该分离，做到在不同的时间做不同的工作。

可能经常也要进行一些周期性或流水线任务，对于这部分工作也可以通过引入开源工具来进行。对于系统或服务的监控也是同样。

做到了上面这些，就达到了自动化分类的第二个层次。

对于如何实现外部维护的通用的自动化系统，可以通过 Perl 或 Python 将各种工具进行胶结和扩展，同时引入数据库对需要的状态结果进行记录保存。

在每个节点机器上，可以采用全服务部署的方式，数据库要独立部署在单独的可靠机器上，根据需要选择性启动不同节点上的服务。
