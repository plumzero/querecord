
主要是集群的自动化。

在运维行为中，`自动化`一般用来指代通过编写代码来解决各种各样的问题。更广泛的说，在这一观点中，自动化是"元软件"，也就是操作其他软件的软件。

多数情况下，以软件为基础的自动化是优于手动操作的，但是比这两个选择更好的方案是一个不需要这些的系统设计 —— 一个自治的系统。或者换一种方式来看，自动化的价值不仅来源于它所做的事情，还包括对其的明智应用。

### 自动化的价值

- 一致性: 保证多次运维、操作下都以同样的方式(执行范围明确、步骤已知)进行，避免因为不一致性导致的错误、疏漏、数据质量问题和可靠性问题。
- 平台性: 可以提供一个可以扩展的、广泛适用的平台，从而执行更多的任务。
- 降低修改时间: 平台同时也将错误集中化了，也就是说，在代码中修复某个错误可以保证该错误被永远修复。如果自动化能够始终正常运行，那么就可以降低一些常见故障的平均修复时间(MTTR)。
- 实现快速修复: 在产品生命周期中更早的发现问题，更早的修复，避免后期修复代价提高。
- 提高行动速度: 这是可以想见的。不过要将自动化的范围进行明确定义，在出现问题时及时停止或转为人工干预，避免问题恶化。
- 节省时间: 将任务进行自动化封装，任何人都可以执行它们，有效地将操作与具体操作人解耦。

### 自动化的内容

> 自动化的内容:
> 1. 部署自动化
> 2. 发布自动化
> 3. 配置自动化
> 4. 监控自动化
> 5. 回退自动化
> ...

部署可以考虑的内容:
- 目标系统用户环境(环境变量与可用工具等)
- 系统资源状况
- 依赖服务版本

发布要考虑的内容包括:
- 源代码管理
- 编译器版本
- 配置语言
- 包管理器和安装器
- 依赖库

更多关于[发布的内容](04_发布工程.md)

配置要考虑的内容:
- 格式正确性校验
- 内容合理性校验
- 配置方式(后台/界面/命令行等)

对于服务状态的监控内容可以考虑的方向有:
- 服务管理: 保障服务运行(例如，在段错误后重新启动、依赖服务关系的变更)
- 跟踪哪些服务应该运行在哪些机器上
- 日志消息解析: 利用正则表达式过滤日志

回退应考虑的内容:
- 可执行程序的回退
- 读写文件的回退
- 配置的回退
- 依赖服务的回退

### 自动化分类的层次结构

- 1. 没有自动化: 操作人员触发手动操作
- 2. 外部维护的系统特定的自动化系统: 操作人员编写，系统特定的自动化
- 3. 外部维护的通用的自动化系统
- 4. 内部维护的系统特定的自动化
- 5. 不需要任何自动化的系统: 不需要人为干预的自治系统

> 当前处于 1 和 2，利用 Airflow 和 Gitlab-runner 先期阶段做到 3，利用 Perl 和数据库支持可以做到 4 。 
> 当前可预见的难点在于包的分布式分发中，利用 Airflow 和 Gitlab-runner 通过 SSH 可以应对繁琐的包分发和服务初始化问题，但无法做到对服务状态和系统资源的监控及对监控内容的扩展。
> 包分发和服务初始化应该分离。包分发要进行必要的一致性检测，而服务也要进行依赖性(文件、配置、版本或其他服务等)检测。
> 自动化程序性内容主要包括两个方面: 一是监控，二是状态。前者可以通过 Perl 构建，后者可以通过数据库进行文件保存与状态和配置发布。

更多监控内容查看[这里](01_监控系统.md)。
