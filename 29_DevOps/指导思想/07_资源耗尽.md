
某一种资源的耗尽可以导致高延迟、高错误率，或者低质量回复的发生。在负载不断上升到过载时，服务器不可能一直保持完全正常。

不同种类的资源耗尽会对软件服务器产生不同的影响。

### CPU

如果 CPU 资源不足以应对请求负载，一般来说所有的请求都会变慢。这个场景会造成一系列的副作用，包括如下几项。

- 正在处理的(in-flight)请求数量上升
  
  因为处理请求需要较长的时间，同一时间服务器必须同时处理更多的请求(上升到一定数量可能会开始进入队列排队)。这会影响其他所有的资源，包括内存、活跃线程数(在每个请求一个线程的编程模型下)、文件描述符，和后端服务器的资源(该资源的耗尽可能会带来其他连锁问题)。

- 队列过长
  
  如果没有足够的资源以稳定的速度处理所有请求，服务器会逐渐将请求队列填满。这意味着延迟上升(因为所有请求都要排队一段时间)，同时队列会使用更多的内存。

- 线程卡住

  如果一个线程由于等待某个锁而无法处理请求，可能服务器无法在合理的时间内处理健康检查请求。

- CPU 死锁或者请求卡住
  
  服务器内置的看门狗(watchdog)可能会检测到服务器无法进行工作，导致软件服务器最终由于 CPU 资源不够而崩溃。如果看门狗机制是远端触发的，但是由于请求队列排队，这些请求无法被及时处理，而触发看门狗机制杀掉进程。

- RPC 超时

  服务器过载时，对客户端 RPC 的回复会变慢，最终会超过客户端所设置的超时时间。这会导致服务器对请求实际进行的处理都被浪费了，而客户端可能会重试 RPC，造成更严重的过载。

- CPU 缓存效率下降

  CPU 使用得越多，任务被分配到多个 CPU 核心上的几率越大，从而导致 CPU 核心本地缓存的失效，进而降低 CPU 处理的效率。

### 内存

同时处理的请求数量升高也会消耗更多的内存用于存放请求、回复以及 RPC 对象。内存耗尽可能导致如下情况的发生。

- 任务崩溃

  例如，某任务可能会因为超过资源限制而被容器管理器驱逐(VM或者其他)，或者程序自身逻辑会触发崩溃。

- 垃圾回收(GC)速率加快，从而导致 CPU 使用率上升

  一个糟糕透顶的场景: 由于 CPU 资源减少，请求处理速度变慢，内存使用率上升，导致 GC 触发次数增多，导致 CPU 资源的进一步减少。此即"GC死亡螺旋"。

- 缓存命中率下降

  可用内存的减少可能会导致应用层缓存的命中率降低，导致向后端发送更多的 RPC，可能会导致后端任务过载。

### 线程

线程不足可能会导致错误或者导致健康检查失败。如果服务器为此增加更多线程，这些线程可能会占用更多内存。在极端情况下，线程不足可能会导致进程 ID 数不足(Linux 的进程 ID 数是有限的)。

### 文件描述符

文件描述符不足可能会导致无法建立网络连接，进而导致健康检查失败。

### 资源之间的相互依赖

很多资源的耗尽都会导致其他资源出现问题 —— 某个服务过载经常会出现一系列次级现象看起来很像根本问题，这会使定位问题更困难。

