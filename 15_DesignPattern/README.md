
*跨越三千年的时光，在此与你相逢...*

*当你试图解决一个你不理解的问题时，复杂化就产成了。*

### 前言

设计模式提供了一种方便的方式，来使用一致并且易于理解的格式捕捉、记录、组织和传播现有的知识。

设计模式不同于算法或数据结构，其概念不能被编写或用作子例程或目标类。设计模式也不同于框架，它们并不描述某个完整系统的结构。相关的设计模式一般会一起使用，共同解决给定的上下文中某个通用的设计问题，是对架构形式最通用的重用方式。

### 轮廓

对设计模式的描述一般都遵循一种相当标准的轮廓，这个轮廓则下面这些项组成:
* 模式名，用来标识该模式，如 Singleton 或 Reactor
* 模式的结构图解，使用 UML 图
* 模式所属的分类，例如创建型(creational)、动作型(behavioral)或结构型(structural)
* 设计问题的图表描述，提供使用这个模式的动机
* 模式适用情形的描述
* 模式参与者的描述
* 对于模式如何支持其目标的描述
* 模式实现的例子和规定的准则

### 内容

创建型模式
* [Singleton模式](01_Singleton)
* [Builder模式](02_Builder)
* [Prototype模式](03_Prototype)
* [Factory Method模式](04_Factory_Method)
* [Abstract Factory模式](05_Abstract_Factory)

动作型模式
* [Iterator模式](06_Iterator)
* [Template Method模式](07_Template_Method)
* [Mediator模式](08_Mediator)
* [Observer模式](09_Observer)
* [Visitor模式](10_Visitor)
* [Chain-of-Responsibility模式](11_Chain_of_Responsibility)
* [State模式](12_State)
* [Memento模式](13_Memento)
* [Command模式](14_Command)
* [Interpreter模式](15_Interpreter)

结构型模式
* [Facade模式](16_Facade)
* [Adapter模式](17_Adapter)
* [Bridge模式](18_Bridge)
* [Composite模式](19_Composite)
* [Decorator模式](20_Decorator)
* [Flyweight模式](21_Flyweight)
* [Proxy模式](22_Proxy)
* [Strategy模式](23_Strategy)

池模式
* [线程池模式](24_Thread_Pool)
* [连接池模式](25_Connect_Pool)
* [内存池模式](26_Memory_Pool)
* [对象池模式](27_Object_Pool)
