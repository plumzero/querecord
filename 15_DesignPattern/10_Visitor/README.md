
### 说明

美其名曰: 将数据结构与处理分离开来。

### 实现

将目录条目打印出来。目录条目分为两种: 文件和目录，是两种不同的数据结构，现在要分开对它们进行处理(这里是打印两种目录条目)。

先定义关于数据结构(File 和 Directory)的处理类，即访问者类(Visitor)，其重载了针对不同数据结构处理的不同方法，这些方法后续会在相应的数据结构类中定义的方法中调用执行。

之后定义目录条目的基类 Entry ，并定义处理不同目录条目(数据结构)的方法 accept ，该方法交由子类实现，accept 方法中的实现会委托给在访问者类中定义的相应方法中实现。

[示例程序](realize.cpp)
  
### 思考

从上例中可以看出，数据结构与打印处理分开了。不过在上面这个示例中，完全可以在基类 Entry 中定义一个虚方法，交由子类实现，比使用访问者模式书写简单且容易理解。

不过在子类继承较深的时候，如果在顶层基类定义这样的一个打印方法，那么可能需要在层层子类中都要进行对应的实现(可能在某些子类中实现这样的方法并没有什么意义)，那样就麻烦了。这个时候不妨考虑使用访问者模式(但是细细想来，也可以在上层父类中定义一个虚方法)。

不管怎样，在后续维护中如果要添加新功能的话，使用访问者模式可以有效地与已有的代码进行分离，减少对已有代码的修改，不失为一个好办法。

回到定义上来，既然是将数据结构与处理分离开来，那么其中一方实现为单纯的数据结构更好一些，而另一方只作为一个单纯的功能类。比如对同一种数据结构，可能要进行不同的编码(如 asn1, json, xml 等)，这个时候使用访问者模式就比较适合。

与桥接模式中功能与数据结构的桥接有所区别，功能类中会内聚对数据结构的一个指针，对数据的处理是由功能方完成的，而访问者模式中数据结构中有定义自己的处理方法，只不过内部委托给访问者执行。

对 tinyxml2 的实现中用到了访问者模式，学习者可以用作参考。
