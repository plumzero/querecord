
### 说明

美其名曰: 将数据结构与处理分离开来。

## 实现

将目录条目打印出来。目录条目分为两种: 文件和目录，是两种不同的数据结构，现在要分开对它们进行处理(这里是打印两种目录条目)。

先定义关于数据结构(File 和 Directory)的处理类，即访问者类(Visitor)，其重载了针对不同数据结构处理的不同方法，这些方法后续会在相应的数据结构类中定义的方法中调用执行。

之后定义目录条目的基类 Entry ，并定义处理不同目录条目(数据结构)的方法 accept ，该方法交由子类实现，accept 方法中的实现会委托给在访问者类中定义的相应方法中实现。

[示例程序](realize.cpp)
  
### 思考

从上例中可以看出，数据结构与打印处理分开了。不过这样真的有必要的吗？完全可以在基类 Entry 中定义一个打印方法，交由子类实现，比访问者书写简单且容易理解。

所以访问像上面这样对访问者模式的使用仅作示例，生产中这样使用属于卖弄机巧，故作学问。

回到定义上来，既然是将数据结构与处理分离开来，那么其中一方实现为单纯的数据结构更好一些，而另一方只作为一个单纯的功能类。比如对同一种数据结构，可能要进行不同的编码(如 asn1, json, xml 等)，这个时候使用访问者模式就比较适合。

与桥接模式中功能与数据结构的桥接有所区别，功能类中会内聚对数据结构的一个指针，对数据的处理是由功能方完成的，而访问者模式中数据结构中有定义自己的处理方法，只不过内部委托给访问者执行。

另一种更常用的应用场景: 对于一份凝聚了前人诸多心血的代码，后继者们肯定是不愿意染指的。但别无选择时需要增加某项功能，这时就可以考虑访问者模式，即根据需求在心血代码里面加两行类似于 access 的方法，而真正的实现在访问者类中完成。

但无论怎么，感觉访问者模式在一般应用中还是很少的。

对 tinyxml2 的实现中用到了访问者模式，学习者可以用作参考。
