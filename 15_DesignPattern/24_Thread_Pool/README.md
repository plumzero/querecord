
## 说明
- 在处理大量并发任务的时候，如果按照传统的方式，一个请求一个线程来处理任务，大量的
  线程创建和销毁将消耗过多的系统资源，还增加了线程上下文的开销，而这些问题可以通过
  线程池技术解决。
- 线程池技术通过在系统中预先创建一定数量的线程，当任务请求到来时，从线程池中分配一
  个预先创建的线程去处理任务，线程在处理完任务之后还可以重用，不会销毁，而是等待下
  次任务的到来。
- 通过线程池能避免大量的线程创建和销毁动作，从而节省系统资源，这样做的一个好处是，
  对于多核处理器，由于线程会被分配到多个CPU，会提高并行处理效率。另一个好处是每个
  线程独立阻塞，可以防止主线程被阻塞而使主流程被阻塞，导致其他请求得不到响应。

## 技术分析
- 流程图示意如下
  <h1 align="center">
    <img width="848" height="441" src=".resource/threadpool-1.jpg" alt="...">
  </h1>
- 一开始线程池会启动一定数量的线程，这些线程属于异步层，主要用来并行处理排队层中的
  任务，如果排队层中的任务数为空，则这些线程等待任务的到来，如果发现队列中有任务了，
  线程池则会从等待的线程这些线程中随机唤醒一个来处理新任务。同步服务层则会不断地将
  新的任务添加到同步排队层中。
- 异步服务层存在多个线程等待处理任务时，通过条件变量(notify_one 或 notify_all)来实现
  对任一线程的随机唤醒。
- 有可能上层的任务较多，而任务处理又是非常耗时的，这时异步层中的线程处理不过来，而同
  步排队层中的任务又不断增加，如果同步排队层不加上限控制，则可能会导致排队层中的任务
  过多，内存暴涨的问题。
- 同步队列主要作用是保证队列中共享数据线程安全，还为上一层同步服务层提供添加新任务的
  接口，以及为下一层异步服务层提供取任务的接口。同时还要限制任务数量。

## 具体实现
- 同步队列实现: SyncQueue.h
- 需要注意三点实现:
    + 这里为了控制数据队列的长度，又引入了一个条件变量，这样一共就有两个条件变量，二
      者在不同状态下分别对锁进行绑定；
    + 对于 void Take(std::list<T>& list) 接口，是考虑到队列可能有多条数据的情况，如果
      每次加锁只获取一条数据，效率是很低的。通过增加这个接口，做到一次加锁就能将队列
      中的所有数据都取出来，减少了加锁次数，提高了效率；
    + void Stop() 函数中对 std::lock_guard 对象进行了作用域控制。因为 notify_one 或 
      notify_all 会唤醒一个等待的线程，线程被唤醒之后，会先获取 mutex 再检查条件是否
      满足，如果这时被 lock_guard 保护，被唤醒的线程需要 lock_guard 析构释放 mutex 才
      能获取锁。对 lock_guard 进行作用域控制后，就可以在退出关键区后立即释放锁，随后
      向其他线程发送信号，流程得到了优化。
- 线程池实现: ThreadPool.h
- 需要注意一些实现:
    + 线程池类中并没有显式定义锁或条件变量，因为所有的处理都是在同步队列中实现的，算
      是一个非典型实现。
    + 应该创建多少个线程由传入参数决定，一般建议创建CPU核数的线程以达到最优的效率。

## 其他实现
- 示例程序: simple.cpp
- 主要成员是一个线程数组和一个任务队列，在未运行(未调用 ThreadPool_run)之前，二者并没
  有任何关联，所以 ThreadPool_init 和 ThreadPool_addTask 调用顺序并不做具体要求。
- 定义 std::once_flag 变量，确保执行完毕后，对所有线程的销毁只执行一次

## 注意
- 主线程并不会执行任务处理，在创建子线程完毕后，主线程应该挂起，等待任务执行完毕。
- 生产上，作为一个服务，线程池应该是一直在运行着的，即使任务队列为空。
