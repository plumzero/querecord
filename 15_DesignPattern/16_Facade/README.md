
### 说明

程序这东西总是会变得越来越大。随着时间的推移，程序中的类会越来越多，而且它们之间相互关联，这会导致程序结构也变得越来越复杂。我们在使用这些类之前，必须先弄清楚它们之间的关系，注意正确的调用顺序。

特别是在调用大型程序进行处理时，我们需要格外注意那些数量庞大的类之间错综复杂的关系。不过与其这么做，不如为这个大型程序准备一个"窗口"。这样，就不必单独地关注每个类了，只需要简单地对"窗口"提出请求即可。这个"窗口"就是 Facade 模式。

使用 Facade 模式可以为互相关联在一起的错综复杂的类整理出高层接口(API)。其中的 Facade 角色可以让系统对外只胡一个简单的接口(API)。而且，Facade 角色还会考虑到系统内部各个类之间的责任关系和依赖关系，按照正确的顺序调用各个类。

### realize 实现

窗口模式常常应用于将底层相互之间没有关联的类，统一于上层的应用类中。底层角色各自完成自己的工作，它们并不知道 Facade 角色。Facade 角色调用其他角色进行工作，但是其他角色不会调用 Facade 角色(但不尽然，也可能会传入 Facade 角色指针以使 Facade 角色中的某些成员供底层角色使用，如日志句柄。不过无论如何，底层角色都不应该调用 Facade 角色中的方法)。

平时如果稍加留意的话，会发现很多项目会用到这种模式。

此种模式比较简单，不做详述。

### 相关的设计模式

Abstract Factory 模式
- 可以将 Abstract Factory 模式看作生成复杂实例时的 Facade 模式。因为它提供了"要想生成这个实例只需要调用这个方法就 OK 了"的简单接口。

Singleton 模式
- 有时会使用 Singleton 模式创建 Facade 角色。

Mediator 模式
- 在 Facade 模式中， Facade 角色单方面地使用其他角色来提供高层接口(API)。
- 而在 Mediator 模式中， Mediator 角色作为 Colleague 角色间的仲裁者负责调停。可以说 Facade 模式是单向的，而 Mediator 角色是双向的。
