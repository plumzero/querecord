
数据库管理系统中并发控制的任务便是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性、数据的一致性以及数据库的一致性，也就是解决丢失更新、脏读、不可重复读、幻读、序列化异常的问题。

并发控制模型有基于锁的并发控制(Lock-Based Concurrency Control)和基于多版本的并发控制(Multi-Version Concurrency Control)。封锁、时间戳、乐观锁和悲观锁是并发控制采用的主要技术手段。

### 基于锁的并发控制

基本的封锁类型有两种： 排它锁(X 锁)和共享锁(S 锁)。
* 排它锁: 被加锁的对象只能被持有锁的事务读取和修改，其他事务无法在该对象上加其他锁，也不能读取和修改该对象。
* 共享锁: 被加锁的对象可以被持锁事务读取，但不是能被修改，其他事务也可以在上面再加共享锁。

封锁策略一次只能执行一个事务，所以只会产生串行调度，迫使事务只能等待前面的事务结束之后才可以开始，所以基于锁的并发控制机制导致性能低下，并发程度低。

### 基于多版本的并发控制

如果每一数据项的旧值副本保存在系统中，这些问题就可以避免。这种基于多个旧值版本的并发控制即 MVCC。一般把基于锁的并发控制机制称为悲观机制，而把 MVCC 机制称为乐观机制。

锁是一种预防性的机制，读会阻塞写，写也会阻塞读，当封锁粒度较大，时间较长时并发性能就不会太好。MVCC 是一种后验性的机制，读不阻塞写，写也不阻塞读，等到提交的时候才检验是否有冲突。MVCC 避免了大粒度和长时间的锁定，能更好地适用对读的响应速度和并发性要求高的场景，大大提升了并发性能。

### 支持事务的 DDL

PostgreSQL 事务的一个高级功能就是它能够通过预写日志设计来执行事务性的 DDL。也就是把 DDL 语句放在一个事务中，比如创建表、TRUNCATE 表等。

```sql
    testdb=*> CREATE TABLE tbl_test(ival int);
    CREATE TABLE
    testdb=*> INSERT INTO tbl_test VALUES(1);
    INSERT 0 1
    testdb=*> ROLLBACK;
    ROLLBACK
    testdb=> SELECT * FROM tbl_test;
    ERROR:  relation "tbl_test" does not exist
    LINE 1: SELECT * FROM tbl_test;
                        ^
```
