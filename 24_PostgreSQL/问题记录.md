
### 删除角色报错

```sh
    postgres=# drop role airflower ;
    ERROR:  role "airflower" cannot be dropped because some objects depend on it
    DETAIL:  privileges for schema public
```

依次执行如下命令:
```sh
    postgres=# drop owned by airflower;
    DROP OWNED
    postgres=# drop role airflower ;
    DROP ROLE
```

### ShareLock

周旋

If a transaction of this sort is going to change the data in the table, then is should use `SHARE ROW EXCLUSIVE` lock mode instead of `SHARE` mode. This ensures that only one transaction of this type runs at a time. Without this, a deadlock is possible: two transactions might both acquire `SHARE` mode, and then be unable to also acquire `ROW EXCLUSIVE` mode to actually perform their updates.(Note that a transaction's own locks never conflict, so a transaction can acquire `ROW EXCLUSIVE` mode when it holds `SHARE` mode —— but not if anyone else holds `SHARE` mode.) To avoid deadlocks, make sure all transactions acquire locks on the same objects in the same order, and if multiple lock modes are involved for a single object, then transaction should always acquire the most restrictive mode first.

Obtain a `SHARE` lock on a primary key table when going to perform inserts into a foreign key table:
```sql
    BEGIN WORK;
    LOCK TABLE films IN SHARE MODE;
    SELECT id FROM films
        WHERE name = 'Star Wars: Episode I - The Plantom Menace';
    -- Do ROLLBACK if record was not returned
    INSERT INTO films_user_comments VALUES
        (_id_, 'GREAT! I was waiting for it for so long!');
    COMMIT WORK;
```

Take a `SHARE ROW EXCLUSIVE` lock on a primary key table when going to perform a delete operation:
```sql
    BEGIN WORK;
    LOCK TABLE films IN SHARE ROW EXCLUSIVE MODE;
    DELETE FROM films_user_comments WHERE id IN
        (SELECT id FROM films WHERE rating < 5);
    DELETE FROM films WHERE rating < 5;
    COMMIT WORK;
```

### ERROR:  canceling autovacuum task

It's normal. It means the autovacuum task was cancelled in order to avoid blocking your regular Postgres sessions.

If it's only during table loading, there's no problem -- the table will be processed later eventually. If it happens all the time, advise setting a cron job to carry out the vacuum task.

通常，出现这种问题有两种原因: 未完结事务及过度使用表锁。

有的时候，在系统资源足够时，数据库性能表现会很差，这个时候就可以查看 autovacuum task 是否有效执行，以便及时清理垃圾信息。如下:
```sql
    SELECT relname, last_vacuum, last_autovacuum, last_analyze, last_autoanalyze FROM pg_stat_user_tables;
```

[参考: Don’t stop PostgreSQL’s autovacuum with your application](https://blog.gocept.com/2012/05/22/dont-stop-postgresqls-autovacuum-with-your-application/)

### WARNING

```sh
    WARNING:  there is already a transaction in progress
    WARNING:  there is no transaction in progress
    WARNING:  there is no transaction in progress
```

quizzer: But with this warning it works correctly, just my boss doesn't like it, i guess.


### 自主事务

PostgreSQL 中不支持自主事务(`autonomous transaction`)，但是可以通过 `SAVEPOINT` 进行类似实现:
```sql
    BEGIN;
    INSERT ...
    SAVEPOINT a;
    some error;
    ROLLBACK TO SAVEPOINT a;
    COMMIT;
```
你可以通过上面的语句部分回退到某个点。示例如下:
```sql
    BEGIN;
        INSERT INTO table1 VALUES (1);
        SAVEPOINT my_savepoint;
        INSERT INTO table1 VALUES (2);
        ROLLBACK TO SAVEPOINT my_savepoint;
        INSERT INTO table1 VALUES (3);
```
在上面的事务中，会向表 table1 中插入 1 和 3，但是不会插入 2 。
