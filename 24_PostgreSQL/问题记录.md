
### 删除角色报错

```sh
    postgres=# drop role airflower ;
    ERROR:  role "airflower" cannot be dropped because some objects depend on it
    DETAIL:  privileges for schema public
```

依次执行如下命令:
```sh
    postgres=# drop owned by airflower;
    DROP OWNED
    postgres=# drop role airflower ;
    DROP ROLE
```

### ShareLock

周旋

If a transaction of this sort is going to change the data in the table, then is should use `SHARE ROW EXCLUSIVE` lock mode instead of `SHARE` mode. This ensures that only one transaction of this type runs at a time. Without this, a deadlock is possible: two transactions might both acquire `SHARE` mode, and then be unable to also acquire `ROW EXCLUSIVE` mode to actually perform their updates.(Note that a transaction's own locks never conflict, so a transaction can acquire `ROW EXCLUSIVE` mode when it holds `SHARE` mode —— but not if anyone else holds `SHARE` mode.) To avoid deadlocks, make sure all transactions acquire locks on the same objects in the same order, and if multiple lock modes are involved for a single object, then transaction should always acquire the most restrictive mode first.

Obtain a `SHARE` lock on a primary key table when going to perform inserts into a foreign key table:
```sql
    BEGIN WORK;
    LOCK TABLE films IN SHARE MODE;
    SELECT id FROM films
        WHERE name = 'Star Wars: Episode I - The Plantom Menace';
    -- Do ROLLBACK if record was not returned
    INSERT INTO films_user_comments VALUES
        (_id_, 'GREAT! I was waiting for it for so long!');
    COMMIT WORK;
```

Take a `SHARE ROW EXCLUSIVE` lock on a primary key table when going to perform a delete operation:
```sql
    BEGIN WORK;
    LOCK TABLE films IN SHARE ROW EXCLUSIVE MODE;
    DELETE FROM films_user_comments WHERE id IN
        (SELECT id FROM films WHERE rating < 5);
    DELETE FROM films WHERE rating < 5;
    COMMIT WORK;
```
