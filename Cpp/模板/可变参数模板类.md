
## 对可变参数模板类的处理
- 一般有两种方法: 递归展开与继承展开。
- 更常用的是递归展开，它又包括两种方法，独立实现与继承自 std::integral_constant 。
- 一般来说，如果在对类型处理时，还需要关注一些额外的东西(如类型长度)，更建议使用继承递归(因为 std::integral_constant 定义了类型的值 value 字段，可用于保存这些值)。如果对类型更关注时，可以采用独立实现，如果使用继承 std::integral_constant 方式，可能会很难实现。

## 关于 integral_constant 类
- 模板类 integral_constant  包装特定类型的静态常量，这样可以在编译时对类型进行检测。
- integral_constant 类是所有 traits 类的基类，C++11 定义如下:
  ```c++
    template <class T, T v>
    struct integral_constant {
        static constexpr T value = v;
        typedef T value_type;
        typedef integral_constant<T,v> type;
        constexpr operator T() { return v; }
    };
  ```

  其成员及功能如下:
    + `value_type`  表示值的类型
    + `value`       表示值
    + `type`        表示自身类型, 因此可以用 ::type::value 来获取 value

- C++11 定义的 traits 类大多继承自 integral_constant 类的特化类 true_type 类和 false_type 类，其定义如下:
  ```c++
    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;
  ```
- constexpr 表示在编译时进行处理。

## 模板递归展开方式参数包
- 可变参数模板类的展开一般需要定义 2~3 个类，包括类声明和特化的模板类，简单示例如下:
  ```c++
    template<typename... Types>
    struct Sum;

    template<typename First, typename... Rest>
    struct Sum<First, Rest...>
    {
        enum { value = Sum<First>::value + Sum<Rest...>::value };
    };
    
    template<typename Last> struct Sum<Last>
    {
        enum { value = sizeof(Last) };
    };
  ```
  这个 sum 类的作用是在编译期计算出参数包中参数类型的 size 之和，通过 sum<int, double, short>::value 就可以获取这 3 个类型的 size 之和为 14 。

  从这个例子可以看出，**一个基本的可变参数模板应用类可以分成三部分**，第一部分是前向声明:
  ```c++
    template<typename... Types> struct Sum;
  ```
  
  第二部分用于定义一个部分展开的可变参数模板类，告诉编译器如何递归展开参数包。
  ```c++
    template<typename First, typename... Rest>
    struct Sum<First, Rest...>
    {
        enum { value = Sum<First>::value + Sum<Rest...>::value };
    };
  ```
  利用 enum 在这里定义一个匿名的枚举类型，它的作用域是 struct Sum<First, Rest...>。value 是该枚举类型的可取值，是为 `Sum<First>::value + Sum<Rest...>::value`，这两者可以通过接下来要说明的递归终止类迭代得出。
  
  第三部分是特化的递归终止类：
  ```c++
    template<typename Last> struct Sum<Last>
    {
        enum { value = sizeof(Last) };
    };
  ```
  
  上面的三部分声明中，在不影响编译的情况下也可以去掉第一部分前向声明部分。

- 递归终止模板类可以有多种写法，比如上例的递归终止模板类还可以像下面这样写，即在展开到最后两个参数时终止:
  ```c++
    template<typename First, typename Last>
    struct Sum<First, Last>
    {
        enum { value = sizeof(First) + sizeof(Last) };
    };
  ```

  在展开到 0 个参数时终止:
  ```c++
    template<>
    struct Sum<>
    {
        enum { value = 0 };
    };
  ```

- 使用 integral_constant 来消除枚举定义 value
  ```c++
    // 前向声明
    template<typename... Types> struct Sum;
    // 基本定义
    template<typename First, typename... Rest>
    struct Sum<First, Rest...> : std::integral_constant<int, Sum<First>::value + Sum<Rest...>::value>
    {
    };
    // 递归终止
    template<typename Last>
    struct Sum<Last> : std::integral_constant<int, sizeof(Last)>
    {
    };
    Sum<int, double, short>::value;     // 值为 14
  ```
  这种方式用到了递归和继承的方式。
  
  与下面要说的递归继承不同，这里递归的是自身，而继承的却是另一个类。下面要说的是，递归的是自身，(递归)继承的也是自身。

## 以 std::tuple 为示例说明模板递归继承方式展开参数包
```c++
    /** 前向声明 */
    template<typename... Types> class tuple;
    
    /** 递归终止条件 */
    template<> class tuple<>{};
    
    /** 递归展开类 */
    template<typename Head, typename... Tail>
    class tuple<Head, Tail...>
        : private tuple<Tail...>
    {
        typedef tuple<Tail...> inherited;   /** 注意，inherited 是一个类型，父类类型 */
    public:
        tuple(){}
        /** inherited(vtail...) 表示调用父类构造函数进行处理 */
        tuple(Head v, Tail... vtail) : m_head(v), inherited(vtail...) {}
        
        Head head() { return m_head; }
        /** 对父类的引用(this 指针指向当前类，通过 inherited& 转型为对父类的引用) */
        inherited& tail() { return *this; }
    protected:
        Head m_head;
    };
```
测试示例:
```c++
    tuple<int, float, string> t(41, 6.3, "nico");
    t.head();   // 41
    # t.tail();   //
    t.tail().head();    // 6.3
```

## 以一种更易理解的方式实现 tuple
```c++
    /** 前向声明 */
    template<typename... Types> class tup;
    
    /** 递归终止条件 */
    template<> class tup<> {};

    /** 复合递归展开类 */
    template<typename Head, typename... Tail>
    class tup<Head, Tail...>
    {
        typedef tup<Tail...> composited;
    protected:
        composited m_tail;
        Head m_head;
    public:
        tup(){}
        tup(Head v, Tail... vtail)
            : m_tail(vtail...), m_head(v) {}
        
        Head head() { return m_head; }
        composited& tail() { return m_tail; }
    };
```
比继承递归展开要容易理解一些。

测试示例：
```c++
    tup<int, float, string> t(41, 6.3, "nico");
    cout << sizeof(t) << endl;
    cout << t.head() << endl;
    cout << t.tail().head() << endl;
    cout << t.tail().tail().head() << endl;
```