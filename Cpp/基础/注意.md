
## fseek 的物理限制
- fseek 在物理上是受到限制的，不提倡频繁调用。
- 在物理上，硬盘、U盘等外部存储器属于"慢速存储设备"，不提倡频繁的读写。否则可能导致：
    + 速度慢、效率低；
    + 每一次 fseek 都要移动物理磁头，这会降低设备的使用寿命。

## sscanf 的使用
- 用 sscanf 从一个具有格式的字符串中提取固定字段，和 scanf 用法类似，要求在格式上要严格匹配。其返回值表示成功提到到的字段的个数。
- 用法示例
  ```c++
    int year, month, day;
    int n = sscanf("2014-12-11", "%d-%d-%d", &year, &month, &day);
    if (n == 3) {
        printf("success: %d, %d, %d\n", year, month, day);
    }
  ```
- sscanf 只适用于提取数字字段，不适合提取字符串类型的字段。而且，当字符串的格式变得复杂时，一般无法用 sscanf 得到正确结果。
  
## const 和 #define 的不同
- 宏是在预处理时替换， const 是在编译过程中处理；
- 从汇编角度看， const 定义常量只是给出了对应的内存地址，而 #define 给出的是立即数。所以 const 定义的常量在程序运行过程中只有一份复制品，而 #define 定义的常量在内存中有若干份复制品。
- 编译器通常不为普通 const 常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，这使得它效率较高。
- 一般写程序时要多用 const ，尤其是在调试时需要追踪由某个名字引起的错误时；过多的使用宏会让调试过程变得困难，陷入“宏地狱”。对于某些特定条件下，可能要定义很多的在相同语境下使用的量，这时使用 const 显然不如宏更有表达性;
  
## ++a 和 a++ 的区别
- ++a 表示取 a 的地址，对它的内容进行加 1 操作，然后把值放在寄存器中;
- a++ 表示取a的地址，把它的值装入寄存器，然后对内存中a的值执行加1操作;
- 可以看出, a++ 不能当做左值使用。++a 可以当做左值使用;

## 关于 sizeof
- sizeof 是 C 语言的关键字，它以字节的形式给出了其操作数的存储大小，操作数可以是一个表达式或括在括号内的类型名;
- sizeof 操作符的结果类型是 size_t;
- sizeof 后如果是类型必须加括弧，如果是变量名可以不加括弧;
- sizeof 对数组名不做退化处理，这与 strlen 不同（会退化成指针）。
- 示例：
  ```c++
    sizeof('\0') = 1;
    sizeof("\0") = 2;
    sizeof("abcdefgh") = 9;
  ```

## 不要对一个指针既使用自操作符，又使用 []
```c++
    int array[5] = { '\0x41', '\0x42', '\0x43', '\0x44', '\0x45' };
    int* p = array;
    ++p;    // *p = '\0x42';
    p[2];   // *p = '\0x44';    p 指针指向的位置已经移动了 1 位
```

## return *this 的返回值
- 若返回值类型为非引用，则返回对象拷贝；
- 若返回值类型为引用，则返回对象本身

## void* 指针的使用
- 对 `void*` 指针不能进行解引用操作或算术操作，否则将引起编译错误。
- 采用 `void*` 的函数通常存在于系统中很低的层次里，在那里需要操作某些真实的硬件资源。
- 在系统中较高层次上出现 `void*` 应该认为是可疑的。

## 结构体中的成员是使用指针还是静态数组？
- 如果该成员长度是不定的，使用指针；如果是固定长度的（如哈希结果），使用静态数组；
- 如果暂时还不确定，但可以确定未来存储的是一段固定长度内容，可以设置成指针或柔性数组形式。
- 对于可读文本字符串，C++ 有更好的解决方式，std::string。

## 与非 C++ 代码的连接
- 使用 extern "C" 在 c++ 中连接 c 代码。
  ```c++
    extern "C" char* strcpy(char*, const char*);
  ```
- 特别地，声明为 extern "C" 的函数仍然要遵守 c++ 的类型检查和参数转换规则，而不是 c 的较弱的规则。
- 使用更方便的连接块：
  ```c++
    extern "C" {
        char* strcpy(char*, const char*);
        int strcmp(const char*, const char*);
        int strlen(const char*);
        // ...
    };
    extern "C" {
        #include <string.h>
    }
  ```
  使用连接块可以包裹起来整个 C 头文件为 C++ 使用。
- 下面这种技术经常被用于由 C 头文件产生出 C++ 头文件。
  ```c++
    #ifdef __cplusplus
    extern "C" {
    #endif
        char* strcpy(char*, const char*);
        int strcmp(const char*, const char*);
        int strlen(const char*);
        // ...
    #ifdef __cplusplus
    }
    #endif
  ```