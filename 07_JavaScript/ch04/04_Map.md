
在 ES6 以前，JS 中实现"键/值"式存储可以使用 Object 来方便高效的完成，也就是使用对象属性作为键，再使用属性为引用值。

Map 是一种新的集合类型，它带来了真正的键/值存储机制。

### 基本 API

使用 new 关键字和 Map 构造函数可以创建一个空映射:
```js
    const m = new Map();
```

可以通过嵌套数组或自定义迭代器方式初始化映射。

[初始化映射示例](t/04_init.js)

可以使用 `set()` 方法添加键/值对，可以使用 `get()` 和 `has()` 进行查询，可以通过 `size` 属性获取映射中的键/值对的数量，还可以使用 `delete()` 和 `clear()` 删除值。

[各类方法示例](t/04_method.js)

与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用任何 JS 数据类型作为键。Map 内部使用 SameValueZero 比较操作，基本上相当于使用严格对象相等的标准来检查键的匹配性。

[各种各样的键](t/04_as_key.js)

与严格相等一样，在映射中用作键和值的对象及其他"集合"类型，在自己的内容或属性被修改时仍然保持不变。

[键是不动的](t/04_key_is_immovable.js)

### 顺序与迭代

与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。

映射实例可以提供一个迭代器(Iterator)，能以插入顺序生成 `[key, value]` 形式的数组。可以通过 `entries()` 方法(或者 `Symbol.iterator` 属性，它引用 entries()) 取得这个迭代器。

[映射的迭代器](t/04_map_iterator.js)

映射也提供了 `forEach(callback, opt_thisArg)` 方法，可以依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值。

[使用forEach方法](t/04_forEach.js)

`keys()` 和 `values()` 分别返回以插入顺序生成键和值的迭代器。

[使用keys和values](t/04_keys_values.js)

键和值在迭代器遍时是可以修改的，但映射内部的引用则无法改变。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份。

[浅修改与修改属性](t/04_modify_attr.js)

### 选择 Object 还是 Map 呢？

1.内存占用

不同浏览器的情况不同，但给定固定大小的内存，Map 大约可以比 Object 多存储 50% 的键/值对。

2.插入性能

插入 Map 在所有浏览器中一般会稍微快一点儿。如果代码涉及大量插入操作，那么显然 Map 的性能更佳。

3.查找速度

二者性能差异极小，但如果只包含少量键/值对，则 Object 有时候速度更快。在把 Object 当成数组使用的情况下(比如使用连续整数作为属性)，浏览器引擎可以进行优化，在内存中使用更高效的布局。

4.删除性能

对大多数浏览器引擎来说，Map 的 delete() 操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map 。
