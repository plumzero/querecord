
## 优先级队列与二叉堆

优先级队列是用二叉堆实现的。 

## 二叉堆的性质
二叉堆从结构性质上说就是一个完全填满的二叉树，同时满足结构性和堆序性。结构性就是完全二叉树应该满足的树结构。堆序性指的是:**父节点的键值总是大于或等于(小于或等于)任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆(都是最大堆或最小堆)**。所以根据二叉堆的堆序性可以分成两种堆:
	**最大堆: 当父节点的键值总是大于或等于任何一个子节点的键值。**
	**最小堆: 当父节点的键值总是小于或等于任何一个子节点的键值。**
这里以最小堆为例进行说明。

## 二叉堆的堆序性
由于堆要保证堆序性，所以在插入、弹出数据时必须要做一些操作保证堆的堆序性。可以在插入的时候通过上浮，在删除的时候通过下沉来实现。
	<h1 align="center">
		<img width="700" height="386" src=".resource/优先级队列.png">
	</h1>
新增:
	1. 最开始是一个最简单的二叉树，只有三个节点两层。
	2.  当新增一个节点15，它在堆的最后，挂在第三层最左侧，父节点是25。所谓的上浮就是新增节点放到最后，然后与父节点比较，它比父节点小则和父节点交换位置，然后再和新的父节点比较，直到顶级或者父节点比它小结束。
	3.  所以15会和25交换位置，然后发现它的父结点20还是比它大，继续交换，上浮到顶级就没有父节点，就完成了上浮。这样就保证了最小的在最上面。
弹出:	
	删除节点则是从顶级弹出，也就是弹出最小值，弹出后顶级节点就变成了空节点，我们就把最后那个节点尾结点取出来，去和顶级节点的两个子节点中较小的比较，如果较小的节点小于尾结点则上浮（顶级节点变成新的最小节点），然后再次用小节点的两个子节点中较小节点和尾节点比较，如此往下递归下去，直到尾结点小于较小子节点，那么就把尾结点设置到当前节点，这就叫下沉。

通过新增节点时上浮，删除节点的下沉永远保证堆顶是最小值，并且每个节点的左子树和右子树都是一个最小堆。

## 二叉堆的实现
实现二叉堆，最重要的是找到节点的子节点和父节点。
我们可以**把二叉堆的数据按照顺序放到数组中，那么在数组n处节点的子节点位置分别是2n+1、2n+2，父节点的位置为n/2**。

## 利用 C++ 序列容器及标准库算法构造二叉堆
- 标准容器适配器 std::priority_queue 通过调用 make_heap, push_heap 和 pop_heap 来维持一个容器的二叉堆特性。
- [C++提供的优先级队列实现方法](heapcpp.cpp)