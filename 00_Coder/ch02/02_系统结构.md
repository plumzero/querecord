
### 集中式存储库结构

集中式存储库架构模型依赖于一个中心过程或者数据结构，该过程(或结构)在系统中担当控制或信息的枢纽(hub)。

在大规模系统当中，协调的任务可能分配给若干个枢纽进程(hub process)，当几个半自治的进程需要协同访问共享资源的信息或资源时，就会用到集中式存储库架构。

当集中式存储库和访问它的应用程序作为独立的进程运行时，这个架构模型通常也称为客户端-服务器模型。可集成性是采用客户端-服务器模型的系统所提供的一项重要的非功能属性。该属性使不同的客户端和服务器可在一个大型的环境中无缝连结。

许多集中式存储库方案都将关系数据库作为其数据仓库来实现。客户端可以通过数据库的结构化查询语言(SQL)访问数据库，或通过一个单独服务器进程所提供的高层的、面向任务的服务来访问。这两种方式分别称为两层架构和三层架构。某些情况下，一个单独的中间服务器会被用做事务监听器，具有集中式的事务收集点，通常提供弹性、冗余、负载分配，以及信息排列等功能。

即使没有数据持久化(由数据库提供)的需求，也会经常用到集中式存储库。在这种情况下，存储库通常作为大量不同代码元素的通信枢纽(communication hub)。通过访问存储库，不相关的代码块之间可以传递信息，却不需要对程序进行组织来适应数据流。这样的存储库也叫做黑板系统(blackboard system)。它通常将松散的数据存储为键/值对，使用公共键命名约定在通信代码间交换信息。若进程位于不同的系统进程当中，则常会用中心服务器及请求-应答(request-reply)机制来对黑板系统进行远程访问。

黑板系统在 Web 服务器中可用来解耦对于请求和应答报头的处理，并且更重要的是，它可作为使数十个不同附加模块与服务器间无缝合作的机制。


### 分布式架构

分布式架构的一个重要组成部分是其底层的通信协议。不过，更通用的方式是使用远程过程调用(RPC)的概念。这使得客户端代码可调用远程服务器上的过程并接收执行结果。实现这种调用需要足够的基础支持 —— 中间件。


概括来讲，最常见的中间件有三种，包括:

CORBA(Common Object Request Broker Architecture, 通用对象请求代理架构)
* 用于在应用程序和应用程序对象之间进行透明的通信。
* 在基于 CORBA 的系统中，都有一个对象请求代理(ORB)将客户端的请求传送到相应的对象实现(object implementation)上。

DCOM(Distributed Component Object Model, 分布式组件对象模型)
* 是一个用来促进分布、异构环境中软件对象间互操作性的面向对象架构。

RPC(Remote Procedure Call, 远程过程调用)
* 用于在不同的网络基础架构间调用远程过程的消息传递协议，与架构和语言无关。

中间件实现思想
* 在使用某种面向对象中间件系统的程序，会将服务器端的方法定义在一些类中，这些类扩展自相应的中间件专有的基类。
* 而在客户端，使用另外的类来定位网络中的服务器，并提供相应的存根(stub)方法将调用(call)重定向给服务器。


### 数据流架构

若处理过程可以建模、设计及实现成一系列数据转换，则可采用数据流架构。

数据流架构常用于面向批处理的自动数据处理环境中，尤其是在有效支持数据转换工具的平台上。另一方面，数据流架构并不适用于反应性系统的设计。

数据流架构的一个明显标志是，使用临时文件或管道在不同的进程间进行通信。

要了解基于数据流架构的系统的功能，需要理解两件事情: 处理过程以及处理过程间流动的数据。过程通常是数据转换。尝试单独理解每个转换，思考其输入和输出。


### 面向对象结构

采用面向对象结构的系统，其设计基于局部维护自身状态的交互对象(interacting object)。系统的架构由不同的类或对象之间的关系，以及对象交互的方式来定义。


### 分层架构

拥有多个可选的同级子系统(peer subsystem)的系统，常常按照分层架构进行组织。在这种架构中，每个独立的层为其上层提供一个定义明确的接口，并使用一个不同但标准的接口与其下层进行通信。在这样一个框架中，每一层可以使用不同的技术或方式来实现，却不会影响整体的架构完整性。

分层架构通常通过堆叠(stack)具有标准化接口的软件组件来实现。在某种意义上，每一层为其上一层提供一个虚拟接口。

进一步拓展一下。

试想有这样一个系统，这个系统未必运行在同一台机器上。有一个转发进程和很多应用进程，转发进程只负责将消息转发给其他应用进程，而应用进程则执行具体逻辑。

刚开始时，转发进程只会向各个应用进程发送一个开始运行逻辑的消息，应用进程各自忙碌了起来。但是逻辑是复杂的，有些应用进程可能会因为各种原因退出，比如因为内存原因被杀掉、程序中错误地关闭了一个文件句柄等。就算我们将这些问题统统解决掉，也不能保证我们的程序后面能够稳定运行不出错，尤其是逻辑变得更加复杂之后。这个时候我们可能会想到，可以对应用进程进行守护，这可以通过定时检测脚本或者开启父进程来实现。

应用进程的守护现在没有问题了。但试想这样一种情况，某个应用进程在收到转发进程的开始运行消息后，会创建一个定时器，这个定时器会每隔 5 分钟创建一个新文件进行操作。在某个 5 分钟时，因为文件句柄关闭原因，导致进程退出了。这个时候，就算应用进程再起来，接下来它也不会再创建文件了。可见，这个系统是脆弱的。

如果我们将这个定时器放到转发进程中，让它每隔 5 分钟向这个应用进程发送一次创建文件指令，而应用只负责创建这个文件并操作就可以了。

那修改后的系统健壮性怎样呢？转发进程还是只负责发送一些简单的消息，不执行复杂的逻辑，没有意外的话，会始终运行。而应用进程即使退出了，它也可以在接下来的 5 分钟后继续接收指令，执行逻辑业务。

看起来，应用进程不再保存自己的状态了。而且，因为转发进程始终处于固定的运行状态，可以设计为一个单例模式。

### 代理结构

