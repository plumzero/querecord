
所有引用基类的地方必须能透明地使用其派生类的对象。

### 理解

也就是说，只有满足以下 2 个条件的面向对象设计才可被认为是满足了里氏替换原则:
- 不应该在代码中出现 if/else 之类对派生类类型进行判断的条件。
- 派生类应当可以替换基类并出现在基类能够出现的任何地方，或者说如果我们把代码中使用基类的地方用它的派生类所代替，代码还能正常工作。

同时里氏替换原则体现了:
- 类的继承原则: 如果一个派生类的对象可能会在基类出现的地方出现运行错误，则该派生类不应该从该基类继承，或者说，应该重新设计它们之间的关系。
- 动作正确性保证: 从另一个侧面上保证了符合里氏替换原则设计原则的类的扩展不会给已有的系统引入新的错误。

里式替换原则为我们是否应该使用继承提供了判断的依据，不再是简单地根据两者之间是否有相同之处来说使用继承。

里式替换原则的引申意义: 子类可以扩展父类的功能，但不能改变父类原有的功能。

具体来说:
- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
- 子类中可以增加自己特有的方法。
- 当子类的方法重载父类的方法时，方法的前置条件(即方法的输入/入参)要比父类方法的输入参数更宽松。
- 当子类的方法实现父类的方法时(重载/重写或实现抽象方法)的后置条件(即方法的输出/返回值)要比父类更严格或相等。

### 优点

- 约束继承泛滥，是开闭原则的一种体现。
- 加强程序的健壮性，同时变更时也可以做到非常好地提高程序的维护性、扩展性。降低需求变更时引入的风险。

### 实现

在很多情况下，在设计初期我们类之间的关系不是很明确，里氏替换原则则给了我们一个判断和设计类之间关系的基准: 需不需要继承，以及怎样设计继承关系。

1. 重构

如果两个具体的类 A，B 之间的关系违反了里氏替换原则(假设是从 B 到 A 的继承关系)，那么根据具体的情况可以在下面的两种重构方案中选择一种:
- 创建一个新的抽象类 C，作为两个具体类的基类，将 A，B 的共同行为移动到 C 中来解决问题。
- 从 B 到 A 的继承关系改为关联关系(比如将一个类的对象作为另一个类的成员指针)。

2. 设计

在进行设计的时候，我们尽量从抽象类继承，而不是从具体类继承。

如果从继承等级树来看，所有叶子节点应当是具体类，而所有的树枝节点应当是抽象类或者接口。当然这只是一个一般性的指导原则，使用的时候还要具体情况具体分析。
