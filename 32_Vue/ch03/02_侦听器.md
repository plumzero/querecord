
计算属性可以用于侦听，不过当需要在数据变化时执行异步或开销较大的操作时，使用 `watch` 更合适。

```html
    <div id="watch-example">
        <p>
            Ask a yes/no question:
            <input v-model="question">
        </p>
        <p>{{ answer }}</p>
    </div>
```

```js
    var watchExampleVM = new Vue({
        el: '#watch-example',
        data: {
            question: '',
            answer: 'I cannot give you an answer until you ask a question!'
        },
        watch: {
            // 如果 `question` 发生改变，这个函数就会运行
            question: function(newQuestion, oldQuestion) {
                this.answer = 'Waiting for you to stop typing...';
                this.debouncedGetAnswer();
            }
        },
        created: function() {
            this.debouncedGetAnswer = _.debounce(this.getAnswer, 500);
        },
        methods: {
            getAnswer: function() {
                if (this.question.indexOf('?') === -1) {
                    this.answer = 'Questions usually contain a question mark. ;-)';
                    return;
                }
                this.answer = 'Thinking...';
                var vm = this;
                axios.get('https://yesno.wtf/api')
                    .then(function(response) {
                        vm.answer = _.capitalize(response.data.answer);
                    })
                    .catch(function(error) {
                        vm.answer = 'Error! Could not reach the API. ' + error;
                    })
            }
        }
    });
```
来分析一下上面的代码都发生了什么。

一切都围绕变量 question 的变化展开，而 question 可以通过用户交互进行改变。

在加载 Vue 时通过 created 预先创建一个名为 debouncedGetAnswer 的函数对象，该函数对象被 watch 调用。在 getAnswer 方法中实现了一个 http 接口，每调用一次 getAnswer 方法就相当于进行了一次 http 请求，而 http 响应会根据结果对 answer 的值进行更新并反映到 DOM 上。

也就是说，用户改变 question 时，watch 侦听其发生变化后才会调用 debouncedGetAnswer 函数，随后调用 getAnswer 函数发送 http 请求，并在 500 时间内无法再次调用。

[程序代码](t/watch.html)
