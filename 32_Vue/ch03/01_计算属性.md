
模板内使用表达式的初衷是用于`简单运算`的。在模板中放入太多的逻辑会让模板过重且难以维护。例如:
```js
    <div id="example">
        {{ message.split('').reverse().join('') }}
    </div>
```
上面的代码中，模板不再是简单的声明式逻辑。对于复杂的逻辑，应当使用 `计算属性`。


### 基本用法

```html
    <div id="example">
        <p>Original message: "{{ message }}"</p>
        <p>Computed reversed message: "{{ reversedMessage }}"</p>
    </div>
```

```js
    var vm = new Vue({
        el: '#example',
        data: {
            message: 'Hello'
        },
        computed: {
            // 计算属性的 getter
            reversedMessage: function() {
                // `this` 指向 vm 实例
                return this.message.split('').reverse().join('');
            }
        }
    });
```
上述代码声明了一个计算属性 reversedMessage 。vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。

### 作用一: 代替方法

计算属性缓存 vs 方法

下列代码中，reversedMessage() 是一个方法:
```html
    <p>Reversed message: "{{ reversedMessage() }}"</p>
```

该方法定义于组件中的 methods 中:
```js
    // 在组件中
    methods: {
        reversedMessage: function() {
            return this.message.split('').reverse().join('');
        }
    }
```
实际运行中，在每次调用 reversedMessage() 方法时，都会进行一次上面的过程(split -> reverse -> join)。在调用较多时，其开销较为可观。如果能够使用计算属性进行代替，则可以避免这种开销。如下:
```js
    computed: {
        reversedMessage: function() {
            return this.message.split('').reverse().join('');
        }
    }
```
`计算属性是基于它们的响应式依赖进行缓存的`，只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。

计算属性类似于其他面向对象编程语言中对象的 get/set 成员函数中的 get 函数(nodejs 中称为 getter)，但又有所不同。对于如下代码:
```js
    computed: {
        now: function() {
            return Date.now();
        }
    }
```
在上面的代码中，我们想要在每次调用 now 时都得到调用时刻的时间。但因为 now 被定义成了计算属性，所以其在随后的调用中将不再更新时间。所以此时定义为方法更符合预期。

### 作用二: 用于侦听

Vue 提供了 `watch` 回调用于侦听指定数据的变动。实际上，计算属性也可以进行此项工作，甚至更好，尤其是当一些数据需要随着其他数据变动而变动时:
```html
    <div id="demo">{{ fullName }}</div>
```

`watch` 侦听:
```js
    var vm = new Vue({
        el: '#demo',
        data: {
            firstName: 'Foo',
            lastName: 'Bar',
            fullName: 'Foo Bar'
        },
        watch: {
            firstName: function(val) {
                this.fullName = val + ' ' + this.lastName;
            },
            lastName: function(val) {
                this.fullName = this.firstName + ' ' + val;
            }
        }
    });
```
上面的代码是命令式且重复的。其计算属性的版本如下:
```js
    var vm = new Vue({
        el: '#demo',
        data: {
            firstName: 'Foo',
            lastName: 'Bar'
        },
        computed: {
            fullName: function() {
                return this.firstName + ' ' + this.lastName;
            }
        }
    });
```

### 计算属性的 setter

计算属性默认只有 getter，不过在需要时也可以提供一个 setter(其本质上仍然是 getter):
```js
    computed: {
        fullName: {
            // getter
            get: function() {
                return this.firstName + ' ' + this.lastName;
            },
            // setter
            set: function(newValue) {
                var names = newValue.split(' ');
                this.firstName = names[0];
                this.lastName = names[names.length - 1];
            }
        }
    }
```
对于上述代码，在运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。
